### 1. **Базовый цикл `for`: под капотом**

```go

for i := 1; i <= 5; i++ {

fmt.Println(i)

}

```

**Что происходит на уровне компилятора?**

1. **Инициализация (once):**

Создаётся переменная `i` с типом `int` (вывод типа из `1`) и значением `1`.

Область видимости: **только внутри цикла**. Вне цикла `i` недоступна.

2. **Проверка условия (перед каждой итерацией):**

Вычисляется `i <= 5`. Если `false` → цикл прерывается.

_Важно: если условие ложно с самого начала (напр., `i := 10; i <= 5`), цикл не выполнится ни разу._

3. **Тело цикла:**

Выполняется `fmt.Println(i)`.

4. **Пост-операция (после каждой итерации):**

Выполняется `i++` (эквивалентно `i += 1`).

_Затем снова шаг 2 → проверка условия._

**Особенности:**

- Любой компонент можно опустить:

```go

// Без инициализации и пост-операции (аналог while)

i := 1

for i <= 5 {

fmt.Println(i)

i++

}

// Бесконечный цикл

for {

// ...

break // обязателен для выхода!

}

```

- **`++` и `--`:**

В Go нет префиксного инкремента (`++i`). Только постфиксного (`i++`).

Эти операции возвращают **старое** значение `i`:

```go

a := i++ // Ошибка! Так нельзя.

```

---

### 2. **Итерация `range`: скрытые детали**

```go

words := []string{"hello", "world"}

for index, word := range words {

fmt.Printf("%d: %s\n", index, word)

}

```

**Как это работает?**

- `range` создаёт **копию** коллекции перед началом цикла.

Если меняете исходный слайс внутри цикла, это не влияет на итерации.

```go

nums := []int{1, 2, 3}

for i, v := range nums {

fmt.Print(v) // 1 2 3

nums = append(nums, i) // Новые элементы не попадают в цикл!

}

```

- **Для массивов:** Итерация по **значению** (каждый элемент копируется).

Используйте указатель на массив, чтобы избежать копирования:

```go

arr := [3]int{1, 2, 3}

for i, v := range &arr { // Используем указатель

v = 0 // Не изменит arr, т.к. v — копия!

arr[i] = 0 // Так можно (меняем по индексу).

}

```

- **Для карт (maps):** Порядок итерации **случаен** (намеренно рандомизирован в Go).

**Советы:**

- Если нужен только индекс, опускайте значение:

```go

for i := range arr { ... }

```

- Если значение не нужно, используйте `_`:

```go

for _, val := range arr { ... }

```

---

### 3. **`break` и `continue`: контроль потока в деталях**

**`continue`:**

- Не просто переходит к следующей итерации, а:

1. Выполняет **пост-операцию** (если есть `i++`).

2. Проверяет **условие**.

- Пример:

```go

for i := 0; i < 5; i++ {

if i == 2 {

continue // Здесь выполнится i++, затем проверка i < 5

}

fmt.Print(i) // 0 1 3 4

}

```

**`break`:**

- Мгновенно выходит из цикла. Пост-операция **не выполняется**.

- Вложенные циклы: `break` выходит только из **текущего** цикла.

Для выхода из внешнего используйте **метки** (labels):

```go

OuterLoop: // Метка

for i := 0; i < 3; i++ {

for j := 0; j < 3; j++ {

if i*j == 4 {

break OuterLoop // Выход из обоих циклов

}

}

}

```

---

### 4. **Вложенные циклы: оптимизация и подводные камни**

Пример из текста (звёздочки) — алгоритмическая сложность O(n²).

**Как оптимизировать?**

- Предварительно вычислять повторяющиеся значения:

```go

// Было:

for j := 1; j <= rows-i; j++ { ... }

// Стало:

spaces := rows - i

for j := 1; j <= spaces; j++ { ... }

```

Это экономит вычисление `rows-i` на каждой итерации внутреннего цикла.

**Ошибки новичков:**

- **Бесконечные циклы:** Если забыть пост-операцию:

```go

for i := 0; i < 5; { // Нет i++ → условие всегда true

fmt.Println(i)

}

```

- **Изменение счётчика внутри цикла:**

```go

for i := 0; i < 5; i++ {

i = 10 // Цикл завершится после первой итерации (i станет 10, затем i++ → 11, условие 11 < 5 — ложно)

}

```

---

### 5. **Новое в Go 1.22: `range` по целым числам**

```go

// Диапазон: от 0 до n-1

for i := range 5 {

fmt.Println(i) // 0, 1, 2, 3, 4

}

// Отрицательные числа? Нет: range -5 вызовет панику!

```

**Под капотом:**

Компилятор преобразует `range n` в классический цикл:

```go

// Примерный код, генерируемый компилятором:

for i := 0; i < n; i++ {

// тело цикла

}

```

**Особенности:**

- Можно использовать для создания слайсов:

```go

var arr []int

for i := range 10 {

arr = append(arr, i)

} // [0 1 2 ... 9]

```

- Работает с `break`/`continue` как обычный цикл.

---

### 6. **Практические упражнения для закрепления**

1. **FizzBuzz в Go:**

Для чисел от 1 до 100:

- Если число делится на 3 → вывести "Fizz".

- Если на 5 → "Buzz".

- Если на 3 и 5 → "FizzBuzz".

- Иначе — число.

2. **Обратная пирамида:**

Модифицируйте пример со звёздочками, чтобы выводить:

```

*********

*******

*****

***

*

```

3. **Итерация по строке:**

Используйте `range` для перебора строки "Привет".

Подсказка: `range` по строке возвращает позицию (byte index) и руну (Unicode символ).

---

### Ответы на скрытые вопросы из текста:

- **Почему `fmt.Printf` вместо `fmt.Println`?**

`Printf` позволяет форматировать вывод. `Println` добавляет пробелы между аргументами и перевод строки.

Пример: `fmt.Println("Index:", index, "Value:", value)` → `Index: 0 Value: 1`.
