Давай разберём этот текст подробно, по строчкам, максимально просто, с понятными примерами и аналогиями. Представь память компьютера как большой шкаф с полками, где мы храним разные коробки (данные). Компилятор — это «рабочий», который заранее раскладывает коробки по полкам, чтобы потом программа могла к ним обращаться.

---

## 1. Объявление переменных: формы и их правила

### 1.1. Классическое объявление с `var`

```go
var age int           // объявление без инициализации → zero value (0)
var name string = "John" // объявление с инициализацией
```

1. `var age int`

   - **Что говорит эта строка?**
     «Я хочу переменную с именем `age` (возраст), тип у неё будет `int` (целое число).»
   - **Без инициализации** значит, что мы не указали сразу значение.
   - **Zero value**: компилятор/рантайм автоматически положит в неё «нулевое значение» для целых чисел — ноль (`0`).
   - **Аналогия**: представь, что ты получил новую коробку на полке, но не положил туда ничего — она по умолчанию пуста (для чисел это 0).

2. `var name string = "John"`

   - Здесь мы и объявляем переменную `name` типа `string` (строка) **и** сразу кладём в неё значение `"John"`.
   - **Аналогия**: ты получаешь коробку для бумажек, и сразу кладёшь туда записку «John».

#### Что делает компилятор «под капотом»

- **Глобальные переменные** (объявлены вне функций, на уровне всего пакета):

  1. Если без инициализации (`var age int`), место резервируется в особой «нулевой» области памяти `.bss`. При загрузке программы эта область автоматически заполняется нулями → `age = 0`.
  2. Если с инициализацией (`var name string = "John"`), место резервируется в области `.data`, где хранятся заранее известные значения. Строка `"John"` лежит в области только для чтения `.rodata`, а в `name` кладётся указатель (адрес) на эту область.

- **Локальные переменные** (внутри функций):

  1. Во время компиляции вычисляется, сколько места нужно на стеке для каждой переменной — например, для `int` на 64-битной архитектуре это 8 байт.
  2. При входе в функцию выделяется фрейм стека — участок памяти, где живут все локальные переменные. Компилятор может вставить инструкцию, обнуляющую эти 8 байт, чтобы гарантировать `age = 0`.

---

### 1.2. Короткое объявление `:=`

```go
name := "Jane"       // компилятор выводит type = string
count := 10          // type = int
```

- **Что означает `:=`?**
  «Создай новую переменную и сразу положи в неё это значение; сам определи её тип.»

- **Где можно использовать**:

  - Только **внутри функций** (локально).
  - Нельзя на уровне пакета (глобально) — компилятор не позволяет, потому что глобальные переменные нужны ещё до запуска функций `init()`/`main()`.

- **Почему так?**

  - Локально удобнее: меньше писать, не нужно указывать тип.
  - Глобально порядок инициализации важен, поэтому всегда `var`.

#### Под капотом

- Для `count := 10`:

  1. Компилятор решает, что `count` займёт 8 байт на стеке.
  2. Генерирует инструкцию типа «запиши 10 в эту ячейку памяти на стеке».
  3. Запоминает, что `count` — это `int`, и дальше при арифметике будет использовать 64-битные инструкции.

---

## 2. Zero value: гарантированное обнуление

> Переменные без явной инициализации получают **нулевое значение** по типу:
>
> - Числа → `0`
> - `bool` → `false`
> - `string` → `""` (пустая строка)
> - Указатели / срезы / карты / функции / интерфейсы / каналы → `nil`

- **Зачем это нужно?**

  - **Безопасность**: ты точно не получишь мусор из предыдущих программ.
  - **Удобство**: не нужно везде писать `= 0`, `= false`, `= ""` или `= nil`.

- **Где хранится эта обнулённая память?**

  - Глобально → в `.bss` (всё автоматически обнулено при загрузке).
  - Локально → компилятор/рантайм очищает стек перед использованием.

---

## 3. Область видимости (scope) и время жизни (lifetime)

### 3.1. Блочная область видимости

#### Локальные переменные

```go
func printName() {
    firstName := "Michael"  // область — только внутри printName
    fmt.Println(firstName)  // OK
}
// Здесь firstName уже не существует
```

- **Где хранится**: в стеке для функции `printName`.
- **Время жизни**: создаётся при входе в функцию, уничтожается при выходе (стек «съедается» обратно).

#### Глобальные переменные

```go
var middleName string = "Cain" // пакет main
func main() {
    fmt.Println(middleName)   // OK
}
```

- **Где хранится**: в областях `.bss`/`.data`, доступных любым функциям в том же пакете.
- **Время жизни**: со старта программы до её завершения.

### 3.2. Почему `:=` запрещён глобально

```go
middleName := "Cain" // compile error: expected declaration
```

- На уровне пакета всегда нужно `var`, даже если хочешь «инференс» типа:

```go
var middleName = "Cain" // тип выведется автоматически, но форма — var
```

---

## 4. Мутабельность и повторное присваивание

- **Переменная** — это просто имя, которое указывает на участок памяти (коробку).

- **Присваивание** (`=`) — перезапись содержимого коробки:

  ```go
  middleName = "Mayor" // теперь в той же коробке лежит "Mayor"
  ```

- **Тип переменной фиксирован** после объявления: нельзя взять и «перевыпустить» ту же переменную с другим типом.

---

## 5. Резюме «под капотом»

| Форма объявления | Где хранится                        | Область видимости        | Zero value                  | Типизация         |
| ---------------- | ----------------------------------- | ------------------------ | --------------------------- | ----------------- |
| `var x T`        | `.bss`/`.data` (глобально) или стек | пакет или локальный блок | обнуляется                  | явный `T`         |
| `var x T = expr` | то же                               | то же                    | инициализируется `expr`     | явный `T`         |
| `x := expr`      | стек (локально)                     | только внутри функции    | нет (инициализируется expr) | выводится из expr |

1. **Компиляция**

   - Компилятор читает код, разбивает на лексемы, проверяет синтаксис и типы, рассчитывает, где и сколько памяти нужно, и генерирует машинный код (инструкции `MOV`, `LEA`, `CALL`).

2. **Сборка (Linking)**

   - Глобальные переменные укладываются в секции `.bss`, `.data`, `.rodata` бинарника.

3. **Запуск**

   - ОС загружает секции в RAM, обнуляет `.bss`, кладёт константы из `.data`, готовит стек. Go runtime запускает `main()`.

4. **Работа программы**

   - При входе/выходе из функций стек выделяется/освобождается, инструкции присваивания записывают данные в нужные ячейки памяти.

---

### Полезные выжимки

- **Глобально** всегда `var`, внутри функций **лучше** `:=` (короче).
- **Zero value** снимает головную боль с инициализацией.
- Локальные переменные **живут** в функции, а глобальные — всё время выполнения программы.
- С `var` ты можешь указать тип вручную; с `:=` — компилятор сам его определит.

---

**Примеры из реальной жизни**

- Представь, что ты кладёшь книги на полку:

  - Глобальные переменные — это книги, которые всегда лежат на полке до тех пор, пока ты не уберёшь их сам.
  - Локальные переменные — книги, которые ты вынимаешь, когда начинаешь читать (функция), и возвращаешь на место, когда закончил (выход из функции).
  - Zero value — это пыльная полка без книг (нулевой мусор): если полка пустая, на ней не останется случайных предметов.

Надеюсь, теперь концепции переменных в Go стали для тебя более понятными! Если что-то осталось неясным, спрашивай — разберём ещё детальнее.
