Мы начинаем изучение Go с арифметических операторов. Автор объясняет, как они работают, и затрагивает важные концепции: целочисленное деление, переполнение и потерю точности. Давайте разберем это подробно, учитывая ваши знания об устройстве компьютера.

### 1. **Арифметические операторы в Go**

Автор перечисляет основные операторы:

- `+` (сложение)

- `-` (вычитание)

- `*` (умножение)

- `/` (деление)

- `%` (остаток от деления, модуль)

**Пример кода:**

```go

var a, b int = 10, 3

var result int

result = a + b // 13

result = a - b // 7

result = a * b // 30

result = a / b // 3 (целочисленное деление!)

result = a % b // 1 (остаток)

```

### 2. **Порядок выполнения операций (приоритет)**

Компилятор Go вычисляет выражения по стандартным математическим правилам:

1. **Скобки `( )`** — высший приоритет.

2. **Умножение, деление, остаток (`*`, `/`, `%`)** — одинаковый приоритет, выполняются слева направо.

3. **Сложение и вычитание (`+`, `-`)** — низший приоритет.

**Пример:**

`2 + 3 * 4` → `3 * 4 = 12` → `2 + 12 = 14`.

Чтобы изменить порядок, используйте скобки: `(2 + 3) * 4 = 20`.

---

### 3. **Особенность целочисленного деления**

**Проблема:**

При делении целых чисел (`int`) результат всегда будет целым, дробная часть **отбрасывается** (не округляется!).

```go

result := 22 / 7 // 3 (а не 3.142...)

```

**Почему так происходит?**

- Go — строго типизированный язык. Если оба операнда целые, компилятор генерирует машинный код для **целочисленного деления**, которое на уровне процессора выполняется инструкцией `DIV` (для x86) или аналогичной. Эта инструкция возвращает только целую часть.

- Дробная часть физически отбрасывается, так как результат помещается в целочисленную переменную.

**Как получить дробный результат?**

Сделайте хотя бы один операнд дробным (тип `float32` или `float64`):

```go

p := 22.0 / 7   // 3.142... (22.0 — float)

p := 22 / 7.0   // тоже сработает

```

**Что происходит под капотом?**

1. Если один операнд дробный, компилятор автоматически приведет второй к дробному типу.

2. Генерируется машинный код для **деления с плавающей точкой** (инструкция `DIVSD` для x86).

3. Результат сохраняется в переменную типа `float`.

---

### 4. **Переполнение (overflow)**

**Что это?**

Когда результат операции превышает максимальное значение типа.

Пример для `int64` (максимум = 9,223,372,036,854,775,807):

```go

var maxInt int64 = 9223372036854775807

maxInt++ // становится -9223372036854775808 (минимальное значение!)

```

**Почему?**

- Целые числа в Go представлены в **дополнительном коде** (two's complement).

- При переполнении происходит "циклический перенос" (wrap around):

`MAX_VALUE + 1 → MIN_VALUE`.

**Аналогично для беззнаковых чисел (`uint`):**

```go

var maxUint uint64 = 18446744073709551615

maxUint++ // становится 0

```

**Зачем это знать?**

При работе с большими числами (финансы, научные расчеты) переполнение может вызвать катастрофические ошибки. Решения:

- Использовать пакет `math/big` для работы с произвольно большими числами.

- Проверять границы значений.

---

### 5. **Потеря точности (underflow)**

**Что это?**

Когда результат операции с дробными числами становится настолько мал, что не может быть представлен типом `float`.

Пример:

```go

smallFloat := 1.0e-323 // очень маленькое число

smallFloat /= math.MaxFloat64 // результат ≈ 0 (underflow!)

```

**Почему?**

- Дробные числа в Go (и большинстве языков) соответствуют стандарту IEEE 754. Тип `float64` имеет ограниченную точность (52 бита мантиссы).

- При операциях, результат которых ближе к нулю, чем `1e-308` (минимальное положительное число для `float64`), значение становится **денормализованным**, а затем — нулём.

**Как избежать?**

- Изменять порядок вычислений, чтобы избегать деления очень больших и очень маленьких чисел.

- Использовать специализированные библиотеки для точной арифметики.
