1. Создание файла и расширение `.go`

### Что говорится в тексте

То есть автор говорит: «Чтобы компьютер понял, что это файл с программой на языке Go, мы называем его `hello.go`. Расширение `.go` (буквы после точки) — условие, по которому инструменты понимают, что это — не просто текст, а исходный код именно на Go.»

### Объяснение «с нуля»

1. **Что такое файл и как его хранит компьютер**

   - Когда вы открываете любой текстовый редактор (например, Блокнот, VS Code или Sublime Text), и начинаете писать буквы, подряд они запоминаются как «байты» в компьютере. Байты — это самые простые «кубики» информации, которые умеет хранить любой диск (HDD или SSD) и запоминать в оперативной памяти (RAM).
   - Файл — это просто набор байтов, сохраненный под каким-то именем (например, `hello.go`) в определенной папке (директории). Компьютер хранит на диске информацию о том, как файл называется, где он лежит и сколько байтов в нём содержится.

2. **Зачем нам расширение `.go`**

   - Расширение — это то, что написано после точки в имени файла. Например, `document.txt`, `picture.jpg`, `script.js`. Расширение помогает и вам, и компьютеру (точнее, операционной системе, вашим программам) понять, с каким типом данных мы имеем дело: текст, картинка, видео, код на каком-то языке и т. д.
   - Если вы напишите обычный текст и сохраните его в `note.txt`, операционная система (Windows, macOS, Linux) и многие программы будут думать: «Это просто обычный текстовый файл». Аналогично, когда вы сохраняете файл с именем `hello.go`, вы и все инструменты, связанные с языком Go, понимают: «Окей, это файл-исходник на Go, его надо обрабатывать специальной программой — компилятором Go.»
   - Если бы вы назвали свой код не `hello.go`, а `hello.txt`, а потом попытались запустить `go run hello.txt`, компилятор Go ответил бы: «Не понимаю — у меня нет файла с расширением `.go`, который можно было бы скомпилировать. Это не программа, а просто текст!»

3. **Как файл оказывается на диске «под капотом»**

   - Вы нажали «Сохранить» → текстовый редактор передал содержимое файла операционной системе → операционная система сделала две вещи:

     1. Поместила байты, которые вы написали, во внутреннюю (оперативную) буферную память контроллера диска.
     2. Затем физически записала эти байты либо на магнитные пластины (если у вас HDD), либо на микросхемы памяти (если у вас SSD).

   - При этом операционная система отметила в своей таблице файлов (так называемой файловой системе), что «имя этого файла — `hello.go`, расположен он по пути, допустим, `C:\Projects\hello.go`, и его размер —, например, 512 байт».

Итак, вывод: **расширение `.go` — просто соглашение, которое помогает понять: «Это исходный код на Go».**

---

## 2. Первая строка в Go: `package main`

```go
package main
```

### Что говорится в тексте

Автор объясняет, что в Go все файлы объединяются в «пакеты» (или «модули»). Когда вы пишете `package main`, вы говорите: «Этот файл принадлежит к пакету с именем `main`. А пакет `main` — это особый пакет, из которого компилятор Go будет собирать исполняемую программу.»

### Объяснение «с нуля»

1. **Что такое пакет (package) в Go**

   - Представьте, что вы пишете несколько файлов, которые вместе делают одну какую-то программу. Часто логично хранить их в одной папке. Go придумал: «Если в папке лежат несколько файлов `.go`, и в каждом из них сверху написано `package xyz`, то все они вместе образуют пакет под названием `xyz`. Всё, что написано внутри, можно ссылаться друг на друга напрямую.»
   - Если вам нужно объединить несколько файлов (допустим, один-файл обрабатывает ввод-вывод, другой-файл считает что-то), вы пишете в обоих файлах одну и ту же строку `package main` (или другое имя пакета), и компилятор понимает: «Все эти файлы вместе — один логический модуль.»

2. **Почему пакет называется `main`**

   - В Go специально зарезервировано имя пакета—`main`. Любая программа, которую вы хотите запустить (получить исполняемый файл), должна быть в пакете `main`. То есть, если вы пишете свою программу `hello.go`, вы начинаете её со строки `package main`. Это сигнал компилятору: «Собери из содержимого этой папки полноценную самодостаточную программу (бинарник).»
   - Если вы создадите пакет с другим именем, например `package utils`, то при компиляции Go соберет из него НЕ исполняемый файл, а «библиотеку» (что-то вроде набора функций, которые можно подключить к программе, но сам по себе этот файл напрямую запустить нельзя).

3. **Что происходит «под капотом», когда вы пишете `package main`**

   - Когда вы запускаете команду `go build` или `go run`, Go-toolchain сканирует папку и смотрит: «Вижу файлы, начинающиеся с `package …`. Все файлы, у которых написано `package main`, объединяются.»
   - Если во всей папке есть хотя бы один файл с `package main`, Go думает: «Хорошо, это проект, из которого нужно построить исполняемый файл.»
   - После этого Go-парсер (часть компилятора) читает «package main» просто как маркер того, что «это не библиотека, а полноценная программа».

4. **Точка входа (entry point)**

   - Если пакет называется `main`, компилятор дальше ищет внутри него функцию `main` (о ней ниже). Именно эта функция — «точка входа». Это как в классической С/С++ или Java: там тоже обязательно нужно объявить функцию (или метод) `main`, куда операционная система передает управление при запуске программы.

Итого: **строка `package main` означает, что «этот код нужно собрать в исполняемую программу»**, а не в библиотеку.

---

## 3. Подключение внешних библиотек: `import "fmt"`

```go
import "fmt"
```

### Что говорится в тексте

Автор говорит, что пакет `fmt` — это часть стандартной библиотеки Go и отвечает за «форматированный» ввод/вывод, то есть за то, чтобы вы могли, например, вывести строку на экран. Когда вы пишете `import "fmt"`, компилятор Go проверяет, есть ли такой пакет среди тех, что установлены в Go, и если есть, он подключает в вашу программу нужную кодовую базу (уже скомпилированную в объектные файлы). Впоследствии, когда вы вызываете `fmt.Println`, компилятор знает, куда «перенаправить» этот вызов и как соединить всё это в один исполняемый файл.

### Объяснение «с нуля»

1. **Зачем вообще «импортировать» (import) что-то**

   - Представьте, что в мире Go есть куча готовых «функций» (нечто вроде маленьких программ или кусочков кода), которые делают удобную работу: вывод текста, работу с числами, работу с сетью, работу с датами и т. д. Эти функции разработаны заранее и хранятся в каталогах (пакетах) на вашем компьютере в специальной папке, куда вы установили Go (обычно это что-то вроде `C:\Go\` или `/usr/local/go/`).
   - Если вам нужно напечатать что-то на экране, можно не писать саму логику «как взаимодействовать с консолью», а просто подключить пакет `fmt`, который это уже умеет делать.

2. **Как Go ищет пакет `fmt` «под капотом»**

   - Когда вы пишете `import "fmt"`, Go сначала ищет папку (или скомпилированный объект) с именем `fmt` в так называемом `$GOROOT/src/fmt/` (там лежат исходники стандартной библиотеки).
   - Если он там есть (а в случае с пакетом `fmt` он есть, он автоматически устанавливается вместе с Go), Go-компилятор добавляет в процесс сборки информацию о том, что «мне нужно взять этот код».
   - В более сложных проектах, где вы используете внешние библиотеки (того же GitHub или других репозиториев), Go будет искать их в папке `$GOPATH/pkg/mod/...` или в папке, где хранится ваш модуль (если у вас есть `go.mod`). Но пока мы говорим про простейший случай — подключение `fmt` из стандартной библиотеки.

3. **Что попадает в ваш исполняемый файл**

   - Когда вы запускаете `go build`, компилятор не просто берёт ваш исходный файл и переводит его в машинный код. Он также берёт код, который лежит в пакете `fmt`, и **линкует** (объединяет) его вместе с вашим кодом.
   - То есть итоговый бинарник содержит и ваш код (например, функцию `main`), и уже готовые машинные инструкции из пакета `fmt`, необходимые, чтобы `fmt.Println` заработал.

4. **Почему без `import "fmt"` вы не сможете вывести текст**

   - Если бы вы не написали `import "fmt"`, а в теле `main` попытались написать `fmt.Println("Hello")`, компилятор бы сказал: «Я не знаю, что такое `fmt` — нет ни одного пакета с таким именем». Получится ошибка «cannot find package "fmt"» или «undefined: fmt». Именно поэтому нужно явно «импортировать» каждый пакет, который вы используете.

Итого: **строка `import "fmt"` говорит компилятору: «Мне нужен код из пакета `fmt` для функции `Println`. Пожалуйста, найдите его в стандартной библиотеке Go и подключите к моей программе».**

---

## 4. Объявление функции `main`: `func main() { … }`

```go
func main() {
    fmt.Println("Hello, World")
}
```

### Что говорится в тексте

Автор объясняет очень подробно, что происходит:

1. Парсер/лексер читают строку `func main() { … }`, распознают ее как объявление функции с именем `main`, без входных параметров, с телом внутри `{}`.
2. Проверяется, что функция `Println` действительно принадлежит пакету `fmt` и что вы передали ей правильный тип данных (строку).
3. Все это переводится в промежуточное представление (SSA), а затем — в машинный код.
4. Затем весь этот машинный код линкуется с машинным кодом из пакета `fmt` и рантайма Go, получается готовый бинарник, и когда вы запускаете его, компьютер (CPU) «читает» инструкцию за инструкцией, вызывает `fmt.Println`, а та, в свою очередь, делает системный вызов к операционной системе, чтобы вывести строку «Hello, World» в консоль.

### Объяснение «с нуля»

Разберем всего по полочкам:

#### 4.1. Что такое функция и зачем `main`

1. **Функция в самом простом понимании**

   - Представьте, что вы спроектировали маленький «инструмент» (программу), который выполняет какую-то задачу. В реальной жизни вы бы каждый раз не брали большой код, а обернули бы повторяющуюся логику в «функцию». Например, «функция сложения» получает два числа и возвращает их сумму.
   - В Go (и во многих других языках) объявление функции начинается со слова `func`, потом идет имя, затем скобки с параметрами, а потом тело в фигурных скобках `{}`.

2. **Почему `main` — особенное имя**

   - В Go, если вы хотите, чтобы ваш код превратился в самостоятельную программу (то есть чтобы его можно было запустить двойным щелчком в Windows или командой `./hello` в Linux), вам нужна функция с ровно таким именем — `main`, и она должна быть в пакете `main`.
   - Как только вы запускаете готовый бинарник, операционная система «ищет» точку входа (entry point). В языках С/С++ это обычно `int main()`, в Java — `public static void main(...)`. В Go — просто `func main()`.

3. **Структура `func main() { … }`**

   - `func` — ключевое слово, то есть «я сейчас объявляю функцию».
   - `main` — имя функции.
   - `()` — параметры. Пустые скобки означают: «эта функция не принимает никаких аргументов извне».
   - `{ … }` — тело функции, то есть то, что будет выполняться, когда эту функцию вызовут.

#### 4.2. Как код «идет» от текста до машинных инструкций

Большинство новичков думают: «я пишу текст, а компьютер сразу его «понимает»». На самом деле между вашим текстом и тем, что реально выполняется процессором, лежит «несколько ступеней перевода». Рассмотрим их:

1. **Лексический анализ (лексер)**

   - Представьте, что у вас есть словарь, в котором перечислены «ключевые слова» языка Go (`func`, `package`, `import` и т. д.), «специальные символы» (`{}`, `()`, `;`, `.` и т. д.) и правила, как разбить текст на «словечки» (токены).
   - Лексер читает файл слева направо и разбивает весь текст на токены: «func», «main», «(», «)», «{», «fmt», «.», «Println», «(», `"Hello, World"`, `)`, `}`.

2. **Синтаксический анализ (парсер) и AST**

   - Когда лексер выдал список токенов, парсер «смотрит» на последовательность токенов и строит из них структуру, похожую на дерево (AST — Abstract Syntax Tree, «абстрактное синтаксическое дерево»).

   - AST для `func main() { fmt.Println("Hello, World") }` можно представить так:

     ```
     FunctionDecl
     ├── имя: "main"
     ├── параметры: []
     └── тело:
         └── CallExpr
             ├── SelectorExpr
             │   ├── X: "fmt"
             │   └── Sel: "Println"
             └── аргумент:
                 └── BasicLit (строка) "Hello, World"
     ```

   - Проще говоря, парсер понимает: «Ага, это объявление функции с именем main, без параметров, внутри — вызов функции Println из пакета fmt со строковым литералом.»

3. **Семантический анализ и проверка типов**

   - После того как AST построено, компилятор проверяет:

     1. Существуют ли все упомянутые идентификаторы (например, функция `Println` — действительно ли она есть в пакете `fmt`).
     2. Правильные ли у вас типы аргументов (например, `Println` может принимать строку, и вы передаёте строку `"Hello, World"` — отлично).
     3. Нет ли попытки использовать несуществующую переменную или функцию.

   - Если где-то что-то не так (например, вызываем `fmt.Prinln` с опечаткой), на этом этапе компилятор выдаёт ошибку и останавливается.

4. **Промежуточное представление SSA и оптимизации**

   - После того как проверка типов пройдена, компилятор переводит AST в более «низкоуровневое» представление (SSA — Static Single Assignment). Это как «упрощённый ассемблер», где всё разбито на элементарные операции.
   - На этапе SSA компилятор уже может выполнить некоторые оптимизации:

     - Убрать «мертвый» код (который никогда не выполнится).
     - Объединить одинаковые вычисления.
     - Решить, какие переменные хранить в регистрах (быстрая память в процессоре), а какие — на стеке или в оперативной памяти.

5. **Генерация машинного кода**

   - После SSA компилятор переходит к конкретной архитектуре (обычно x86_64 на современных компьютерах). Он превращает упрощённое представление в «настоящие» машинные инструкции — набор байтов, которые понимает процессор.
   - Например, чтобы вызвать функцию `fmt.Println`, компилятор генерирует код, который:

     1. Кладёт в регистр (ремень связи) адрес строчной константы «Hello, World».
     2. Вычисляет длину этой строки.
     3. Вызывает машинную инструкцию `CALL`, чтобы передать управление в готовый код функции `Println`.
     4. Когда `Println` возвращается, происходит возврат из функции, и управление снова попадает «домой», в следующие инструкции функции `main`.

6. **Линковка (linking)**

   - Получив сгенерированные машинные инструкции из вашего файла `hello.go`, а также уже имеющиеся сгенерированные машинные инструкции для пакета `fmt` (они либо находятся в кеше в виде объектного файла, либо сразу компилируются заново), компоновщик (linker) объединяет всё это в единый файл.
   - Если вы используете команду `go run`, то Go-toolchain кладёт полученный один большой «объект» (или сразу уже готовый бинарник) во временную папку (обычно `/tmp/...` или аналог), а потом сразу запускает его. Если вы делаете `go build`, результат (финальный бинарник) останется в той же папке, где лежал ваш `hello.go` (например, `hello` на Linux или `hello.exe` в Windows).

#### 4.3. Что происходит при запуске готового бинарника

1. **ОС загружает файл в память**

   - Допустим, вы выполнили `./hello` в терминале Linux. Операционная система читает заголовок файла (он записан в специальном формате ELF на Linux) и понимает: «Это исполняемый файл».
   - ОС выделяет в оперативной памяти (RAM) участки под то, что называется:

     - Секция `.text` (машинный код программы).
     - Секция `.data` и `.rodata` (данные и константы, в том числе строка «Hello, World»).
     - Блок для стека (stack) — туда будут складываться временные данные вызовов функций, локальные переменные и т. п.
     - Территорию для кучи (heap) — туда будет выделяться динамическая память (не нужно в данном простом примере, но в более сложных программах используется).

2. **CPU начинает выполнять инструкции**

   - Как только все секции загружены в нужные адреса памяти, ОС передает управление первому машинному коду, который называется «точка входа». В Go это не сразу `main`, а небольшая часть кода, встроенная в рантайм Go, которая инициализирует среду выполнения Go (планировщик горутин, сборщик мусора, другие «под капотом» штуки). Эти инструкции лежат тоже в секции `.text`.
   - После инициализации рантайм вызывает вашу функцию `main.main()`. CPU считывает первую инструкцию, исполняет её, затем считывает следующую и т. д.

3. **Вызов `fmt.Println` и системный вызов**

   - Как только CPU доходит до инструкции, которая вызывает `fmt.Println`, он переключается на выполнение машинного кода функции `Println`.
   - В теле `fmt.Println` запускается логика по форматированию строки и формированию буфера с символами «Hello, World\n».
   - Затем Go-рантайм вызывает низкоуровневую инструкцию типа `syscall write` (если Linux) или `WriteConsole` (если Windows) — это уже взаимодействие с ядром операционной системы. Ядро получает запрос: «Запиши эти байты в стандартный вывод (stdout)».
   - ОС передает эти байты драйверу терминала, драйвер формирует символы на экране, и вы видите «Hello, World».

4. **Завершение программы**

   - Как только `Println` закончит работу, управление возвращается в вашу функцию `main`. Поскольку после этого в `main` больше нет ни одной инструкции, функция `main` завершается.
   - Go-рантайм получает сигнал, что `main` отработала, и начинает «процедуру завершения»: освобождает временные ресурсы, дожидается завершения всех «горутин» (если они были), завершает сборщик мусора и передаёт управление обратно операционной системе с кодом возврата 0 (что означает «успешно»).
   - Операционная система отмечает процесс как завершенный и возвращает управление вашей командной строке.

Таким образом, **каждая строчка `func main() { fmt.Println("Hello, World") }` проходит через несколько этапов перевода (лексер → парсер → SSA → машинный код → линковка) и в итоге исполняется процессором**, выводя вам привычный сообщение на экране.

---

## 5. Как работает команда `go run hello.go`

### Что говорится в тексте

Автор объясняет, что `go run` — это не какой-то интерпретатор, как в Python. При запуске `go run hello.go` Go-toolchain делает следующее:

1. Создаёт «временную папку» (например, в `/tmp` на Unix-системах).
2. Копирует туда ваш файл `hello.go` (а если есть дополнительные файлы в пакете, он берёт и их).
3. Запускает в этой папке процесс компиляции (`go build`) и получает там временный исполняемый файл (например, `hello_run_123456`).
4. Сразу же запускает этот временный бинарник.
5. Когда ваша программа завершилась, Go-toolchain может удалить этот бинарник (чтобы ваша исходная папка не «засорялась» лишними файлами).

Автор говорит: «год run — это удобно, когда вы быстро хотите что-то проверить. Но, конечно, каждый раз при запуске происходит полная компиляция, поэтому на больших проектах `go run` может быть медленнее, чем запуск уже готового бинарника, собранного командой `go build`.»

### Объяснение «с нуля»

1. **Почему не интерпретатор**

   - В языках типа Python или Ruby вы запускаете «интерпретатор», и он непосредственно читает ваши строки кода, разбирает их и выполняет «как есть» (пошагово).
   - В Go — другой подход. Даже когда вы пишете `go run hello.go`, компилятор сначала переводит ваш код в машинный код, как будто вы делаете `go build`, а уже потом запускает результат (как будто вы скомпилировали и запустили готовый файл).

2. **Зачем создаётся временная папка**

   - Если бы `go run` сразу скомпилировал в папку, где лежит ваш `hello.go`, туда бы засорялся новый файл (бинарник). Со временем в папке с исходниками могла бы накопиться куча скомпилированных исполняемых файлов, мешающих ориентироваться.
   - Поэтому Go-toolchain заранее создаёт где-то во временной области (например, `/tmp/go-build1234/`) папку, копирует туда исходники и там уже выполняет все этапы компиляции.

3. **Как именно Go делает «run»**

   - Вы в командной строке прописываете:

     ```
     go run hello.go
     ```

   - Go-toolchain:

     1. Находит исходник `hello.go` (HDD → читает байты → кладёт в RAM).
     2. Создаёт временный каталог.
     3. Копирует туда все файлы, относящиеся к пакету (если в папке несколько `.go`–файлов, которые принадлежат к `package main`, их тоже копирует).
     4. Запускает компиляцию (то есть фактически `go build` тоже, но в том временном каталоге).
     5. Получает из этого компилятора готовый бинарный файл (скажем, `/tmp/go-build1234/hello_run_98765`).
     6. Немедленно через тот же Unix-системный вызов `execve` (в Linux) или `CreateProcess` (в Windows) запускает этот бинарник в отдельном процессе.
     7. В этом новом процессе операционная система загружает секции `.text` (код), `.data` (данные), создаёт стек, передаёт управление CPU — и тот начинает выполнять инструкцию за инструкцией, пока программа не завершится.
     8. Как только программа заканчивает свою работу, Go-toolchain (который всё ещё ждет результат работы этого процесса) получает код возврата и затем удаляет временный бинарник и все вспомогательные файлы из `/tmp/go-build1234/`.

4. **Достоинства и недостатки `go run`**

   - **Плюс**:

     - Быстро проверить, например, «А что выведет этот маленький кусочек кода?»
     - Нет лишних файлов в рабочей папке — после завершения всё чисто.

   - **Минус**:

     - Каждый раз, когда вы запустите `go run`, даже если вы не меняли код, компилятор сделает всё заново: лексинг, парсинг, SSA, машинный код, линковку → потом запустит.
     - На маленьких тестах это почти не заметно, но если у вас проект из сотен файлов и сложными зависимостями, компиляция может занимать секунды или десятки секунд.

Итак, **команда `go run hello.go` работает как «compile & run» (сначала компиляция, потом запуск), а не как «интерпретатор», читающий код «на лету».**

---

## 6. Как работает команда `go build hello.go`

### Что говорится в тексте

Когда вы пишете:

```
go build hello.go
```

автор говорит, что Go-командная строка компилирует ваш код и создает **постоянный** исполняемый файл (бинарник) в той же папке, где лежал `hello.go`. На Linux он может просто называться `hello` (без расширения), а на Windows — `hello.exe`. Этот файл уже «готов для многократного запуска»: вы можете запустить его сколько угодно раз без повторной компиляции.

### Объяснение «с нуля»

1. **Отличие `go build` от `go run`**

   - `go build` делает практически всё то же самое, что и `go run`, — компиляцию и линковку, — но **не запускает** полученный файл сразу и **оставляет** его в папке с исходниками.
   - Проще говоря:

     - `go run`: «соберись и сразу запустись, а потом удали себя, когда закончишь».
     - `go build`: «соберись и останься в папке, чтобы я мог запускать тебя вручную сколько угодно раз».

2. **Что внутри готового бинарника**

   - После `go build hello.go` в текущей папке вы увидите файл, названный просто `hello` (или `hello.exe` в Windows).
   - Этот файл — не текст, а набор байтов, разделенных на секции. Формат секций зависит от операционной системы:

     - В Linux: формат **ELF** (Executable and Linkable Format).
     - В Windows: формат **PE** (Portable Executable).
     - В macOS: формат **Mach-O**.

   - Давайте разберём основные «секции» внутри ELF (на примере Linux, но идея похожа во всех ОС):

     1. **`.text`** — в ней лежит весь машинный код вашей программы плюс встроенный Go-рантайм (инструкции CPU).
     2. **`.rodata`** — «read-only data», то есть константы: в нашем случае это строка `"Hello, World"`.
     3. **`.data`** — изменяемые глобальные данные (в нашем примере их нет, но в более сложных программах там лежат, например, глобальные переменные).
     4. **`.bss`** — еще одна область для данных, предназначенная для глобальных переменных, автоматически инициализируемых нулём (в нашем простом примере она тоже пустая).
     5. **Символьные таблицы** (если вы не отключали отладочную информацию) — нужно, чтобы дебаггеры могли сопоставить машинный код именам функций и переменных (в режиме отладки). В готовом «релизном» бинарнике отладка обычно отключена, и эти таблицы убираются, чтобы уменьшить размер.
     6. **Секция заголовков** — специальная часть, которую ОС читает в первую очередь, чтобы понять, какой это тип файла, куда нужно монтировать участки памяти (виртуальная адресация), и какая точка входа (entry point).

3. **Статическая линковка Go-рантайма**

   - В отличие от многих языков (например, C/C++ часто линкуется с системными библиотеками через динамическую библиотеку `libc.so`), Go по умолчанию **статически** включает все, что ему нужно, прямо в свой бинарник.
   - Статическая линковка означает, что если вы взяли полученный `hello` и передали другу, он сможет запустить его на идентичной архитектуре и OS, и у него не потребуется ничего «дополнительно установить» (например, пакет Go, какие-то библиотеки). Всё, что необходимо, уже «вшито» внутрь (включая сборщик мусора, планировщик горутин, сетевые библиотеки и т. д.).
   - Плюс: программа более «самодостаточная».
   - Минус: размер бинарника получается больше, чем у аналогичной C-программы, потому что туда попадает полный Go-рантайм.

4. **Что происходит при запуске готового бинарника (например, `./hello`)**

   - Вы в командной строке вводите `./hello`. Операционная система:

     1. Считывает первые байты файла, смотрит заголовок, понимает «Это ELF» (Linux).
     2. Выделяет нужные участки в оперативной памяти (виртуальную память) под каждую секцию (`.text` → код, `.data` и `.rodata` → данные, `.bss` → обнуленные данные, стек и куча для процесса).
     3. Записывает машинный код из `.text` в правоисполняемую область памяти (т. е. помечает память как «execute» в таблице страниц), и данные из `.data` и `.rodata` в области под данные (с правами «read/write» или «read-only», как положено).
     4. Помещает указатель инструкций (PC — Program Counter) на точку входа (это адрес функции `_start` в ELF). На самом деле `_start` организует запуск рантайма Go, а он внутри вызывает `runtime.main`, а оттуда идёт вызов вашей `main.main()`.
     5. CPU начинает выполнять инструкции: инициализируется рантайм Go, потом вызывается ваша `main`, в `main` мы встречаем `fmt.Println("Hello, World")` → тут снова переключение контекста: вызов системного вызова ОС (write на Linux или WriteConsole на Windows) → строка печатается.
     6. По окончании `main` всё завершается, Go-рантайм следит, чтобы все «горутины» (если были) завершились, освобождает ресурсы, и возвращает управление ОС с кодом возврата 0.

5. **Преимущества `go build`**

   - Готовый бинарник можно запускать множество раз без повторной компиляции.
   - Быстрый запуск: берём уже слинкованный исполняемый файл — и вперед.
   - Вы можете раздавать этот бинарник (например, на сервер или другу), не заботясь о том, чтобы на той машине был установлен Go.

Таким образом, **команда `go build hello.go` создает самостоятельный исполняемый файл (ELF/PE/Mach-O), а не просто «хавает» ваш код и тут же удаляет результат**.

---

## 7. Детали работы компилятора Go и рантайма

В этом блоке мы углубимся чуть глубже: как конкретно компилятор Go строит AST, что такое SSA, какие оптимизации он делает, потом как линковщик соединяет всё это в единый файл, и как внутри находится встроенный сборщик мусора и планировщик. Попробую объяснить максимально просто, но с сохранением сути.

### 7.1. Лексинг и синтаксический анализ

1. **Лексер (лексический анализатор)**

   - Берёт «сырой текст» (байты) из файла `hello.go`.
   - Читает построчно, по символам, распознает «слова» (токены):

     - Ключевые слова: `package`, `import`, `func`, `var`, `if`, `for` и т. д.
     - Идентификаторы: имена, которые вы придумали (например, `main`, `fmt`, `Println`).
     - Литералы: числа (в случае, если вы пишете `42`), строки (в кавычках `"Hello, World"`), символы (в одинарных кавычках).
     - Специальные символы: `{`, `}`, `(`, `)`, `;`, `.` (точка для обращения к методам), `,`.

   - В результате лексер выдает список токенов, примерно в таком виде:

   ```
   [Token(package), Token(main), Token(SEMICOLON),
    Token(import), Token(StringLiteral("fmt")), Token(SEMICOLON),
    Token(func), Token(main), Token(LPAREN), Token(RPAREN), Token(LBRACE),
      Token(Identifier(fmt)), Token(DOT), Token(Identifier(Println)),
      Token(LPAREN), Token(StringLiteral("Hello, World")), Token(RPAREN),
    Token(RBRACE)
   ]
   ```

   (`SEMICOLON`, `LPAREN` обозначают соответственно «;», «(» и т. д.)

2. **Парсер (синтаксический анализатор)**

   - Парсер берет этот поток токенов и строит из него дерево (AST), в котором отражается логика программы:

     - «Это объявление пакета main»
     - «Здесь импортируется пакет fmt»
     - «Здесь объявляется функция main, внутри нее вызывается функция fmt.Println со строкой "Hello, World"».

   - AST — это уже не просто «линейный список токенов», а древовидная структура, где каждый узел — это «какая-то конструкция языка»: объявление функции, вызов функции, литерал строки, и так далее.

3. **Зачем нужен AST**

   - AST удобен тем, что на его основе легко проверять семантику (например, находятся ли все идентификаторы, верны ли типы), а затем преобразовать в более низкоуровневое представление. Think of it как «абстрактный план» вашей программы.

### 7.2. Семантический анализ и проверка типов

1. **Семантика**

   - Прежде чем генерировать машинный код, компилятор должен убедиться, что ваше «дизайн-дерево» (AST) действительно имеет смысл.
   - Он проверяет:

     - Существует ли в импортированном пакете функция/переменная, которую вы используете.
     - Соответствуют ли типы: например, если вы написали `fmt.Println(123)`, а `Println` принимает «интерфейс» (в Go у `Println` аргументы имеют тип `interface{}`), это ок. Но если бы вы попытались присвоить число строке или вызывать функцию с неправильным количеством аргументов, возникнет ошибка.
     - Что все переменные задекларированы до использования (хотя в данном простом примере у нас никаких переменных нет, только вызов `fmt.Println`).

2. **Почему Go называют «строго типизированным»**

   - Все данные в Go имеют конкретный тип: число, строка, булевое значение, срез, карта, интерфейс и т. д.
   - Компилятор должен убедиться, что везде, где ожидается один тип, вы не передаете другой. Это делается именно на этапе «семантического анализа».

3. **Ошибки на этой стадии**

   - Если вы где-то ошиблись, компилятор сразу остановится и напишет, на какой строке и в чем проблема (например, «fmt.Println expects arguments of type ..., but you passed type ...»).

### 7.3. Промежуточное представление (SSA)

1. **Что такое SSA (Static Single Assignment)**

   - После того как AST проверен, компилятор переводит программу в промежуточную форму, где каждая переменная «присваивается» только один раз (в SSA-форме). Это упрощает процесс оптимизации.
   - Например, если у вас был код:

     ```go
     a := 1
     b := a + 2
     a = 3
     c := a + b
     ```

     то в SSA вообще каждое «присваивание» рассматривалось бы как «новая» версия `a`. Это позволяет компилятору легче понять, где значение может меняться, а где нет.

2. **Оптимизации на уровне SSA**

   - **Устранение повторяющихся выражений (common subexpression elimination)**

     - Если вы дважды считали одно и то же «1 + 2» в разных местах, компилятор может вычислить это один раз и reuse результат.

   - **Удаление мертвого кода (dead code elimination)**

     - Если какая-то часть кода никогда не выполнится (например, дата «if false { ... }»), компилятор просто выбросит её, чтобы программа стала компактнее и быстрее.

   - **Инлайнинг функций**

     - Если функция очень маленькая (несколько строк), вместо того чтобы делать к ней «CALL» (что требует накладных расходов на сохранение/восстановление состояния CPU), компилятор может «вставить» её тело прямо туда, где вы её вызвали.

   - **Регистровое распределение**

     - Компилятор решает, какие переменные поместить в регистры процессора (они очень быстрые), а какие — в более медленную оперативную память (RAM).

3. **Почему всё это важно**

   - Благодаря SSA-представлению Go-компилятор может генерировать машинный код, который работает быстрее, чем если бы он просто «пробегался» по коду в стиле интерпретатора.

### 7.4. Генерация машинного кода и линковка

1. **Перевод SSA в машинные инструкции**

   - После всех оптимизаций SSA компилятор начинает «описывать» конкретные инструкции для процессора (x86_64 или ARM, в зависимости от того, куда вы целитесь).
   - Каждая операция, например «сложить два числа» или «вызвать функцию», соответствует небольшому набору машинных инструкций (байт-кодов), которые понимает CPU.
   - Например, чтобы сложить два целых числа, может использоваться инструкция `ADD rax, rbx` (сложить регистры RAX и RBX и положить результат в RAX).

2. **Что такое linker (комоновщик)**

   - Когда вы делаете `go build`, компилятор генерирует машинный код для каждого вашего файла в виде объектных файлов (файлы с расширением `.o`, но в Go обычно всё это происходит «за кулисами» и вы их не видите).
   - Потом специальная утилита (линковщик) склеивает (link) все объектные файлы вместе, плюс берёт объекты из пакета `fmt` и рантайма Go (они тоже уже собраны в объектные файлы), и объединяет всё это в единый исполняемый файл.
   - На этом шаге linker связывает все «вызовы» функций с их реальными адресами в памяти (или готовит таблицу, чтобы ОС при загрузке знала, куда их поместить).

3. **Результат линковки**

   - В результате получится один файл:

     - На Linux он будет в формате ELF.
     - На Windows в формате PE с расширением `.exe`.
     - На macOS — Mach-O.

   - Внутри этого файла:

     - Код программы (секция `.text`).
     - Данные (.data, .rodata).
     - Информация для ОС о том, куда какие куски надо грузить в память.
     - Встроенный Go-рантайм (сборщик мусора, планировщик горутин и т. д.).

---

## 8. Почему «package main» и «func main» обязательны

### Что говорится в тексте

Автор обобщает правила языка Go:

1. Если вы хотите получить исполняемый файл, ваш пакет должен называться `main`.
2. Внутри пакета `main` обязательно должна быть функция `main`.
3. Если вы переименовали `package main` в `package root`, даже если внутри есть `func main()`, компилятор скажет, что не может скомпилировать это как программу — ведь пакет теперь не `main`, а `root`.
4. Если пакет называется `main`, а функции `main` нет, компилятор опять выдаст ошибку «missing function main in main package».

### Объяснение «с нуля»

1. **Зачем нужны оба условия: имя пакета и функция**

   - Компилятор Go, когда видит пакет, проверяет: «package имя» → если имя не `main`, значит это просто библиотека, которую нельзя запустить. Из нее можно только собрать набор функций (например, `mylib.a`), но не программу.
   - Если имя пакета `main`, компилятор готовит его для создания исполняемого файла. Но он должен знать: куда передать управление при запуске. Поэтому обязательно нужна функция `func main()`.
   - Сочетание «имя пакета `main` + функция `main`» — это и есть «точка входа» (entry point).

2. **Что если «что-то» не так**

   - **Переименовали `package main` в `package root`** → компилятор думает «Это библиотека, и я ее соберу, но никакой точки входа (главной функции) у меня нет, так как пакет — не `main`». Итог: вы получите собранный файл `.a` (статическую библиотеку) или даже ошибку, что нельзя собирать исполняемый файл (зависит от того, как вы вызываете go build).
   - **Оставили `package main`, но удалили функцию `main`** → компилятор скажет «Error: missing function main in main package», потому что у него нет, куда «заскочить» при запуске.
   - **Пакет называется `main`, функция есть, но сигнатура неправильная (например, `func Main()` с заглавной буквы или `func main(args string)` с параметрами)** → тоже ошибка, потому что сигнатура должна быть ровно `func main()`.

3. **Почему именно так сделано**

   - Во многих языках семейства C требуют точку входа с именем `main`. В Go решили сделать чуть проще:

     - Если хочется собрать «библиотеку» (код, который можно «прикрутить» к другим проектам), можно выбрать любое имя (например, `package mathutils`). Тогда компилятор не будет ожидать функцию `main`, а соберёт «архив» (library) с тем, что вы написали.
     - Если хочется «программу», нужно писать `package main` и `func main()`, и тогда выходной результат — готовая .exe (или ELF) со встроенным рантаймом, которое можно запускать.

Итак, **имя пакета `main` + наличие функции `func main()` — это сигнал для компилятора: «Пожалуйста, сделайте из меня программу, и я обещаю, что там будет точка входа `main`».**

---

## 9. Разница между командой `go run` и `go build`

Автор подводит итог в виде таблицы:

| Команда              | Что делает «под капотом»                                                                                                                                                                                            | Итог для вас                                                                                         |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `go run <файл.go>`   | 1. Создаёт временную директорию.<br>2. Копирует исходники.<br>3. Компилирует внутренним `go build` в временный бинарник.<br>4. Запускает полученный бинарник.<br>5. По окончании работы удаляет временный бинарник. | Быстрый запуск без мусорных файлов, но каждый раз компилирует заново.                                |
| `go build <файл.go>` | 1. Компилирует напрямую текущие исходники.<br>2. Линкует с библиотеками/рантаймом Go.<br>3. Создаёт исполняемый файл в текущей папке.                                                                               | Получаете готовый `.exe`/ELF-бинарник, который можно запускать многократно без повторной компиляции. |

### Объяснение «с нуля»

Мы уже частично повторяли выше, но коротко еще раз:

- **`go run`**

  1. Создает временную папку (например, `/tmp/go-build1234/`).
  2. Копирует туда ваш `hello.go` (и другие `.go`-файлы пакета).
  3. Выполняет там `go build` (генерирует бинарник).
  4. Сразу запускает получившийся бинарник.
  5. После завершения работы программы сразу удаляет сгенерированный бинарник и папку.

  - **Вывод:** Если вы быстро хотите протестировать идею или пример, не хотите засорять свою рабочую папку, `go run` — удобно. Но при каждом запуске будет заново пересобираться код.

- **`go build`**

  1. Сразу компилирует ваши текущие файлы в том же месте, где вы их редактируете.
  2. Линкует код с библиотеками и встроенным рантаймом Go.
  3. Создает исполняемый файл `hello` (или `hello.exe` в Windows) в текущей папке.

  - **Вывод:** Если вы хотите получить готовую программу, чтобы запускать её много раз или передавать кому-то, используйте `go build`.

Разница в конечном итоге сводится к тому, что `go run` упрощает жизнь для быстрой проверки, но всегда тратит время на компиляцию заново, а `go build` создает постоянный файл, который можно запускать быстро без дополнительной пересборки.

---

## 10. Как Go-рантайм и garbage collector (GC) «вшиваются» в бинарник

### Что говорится в тексте

Автор говорит, что в Go не получается «собрать» код без рантайма — всё, что отвечает за управление горутинами (легковесными потоками), сборщиком мусора, синхронизацией — всё это встроено прямо в получаемый бинарник. Это называется «статическая линковка рантайма». Благодаря этому Go-программы «самодостаточны»: если дали вам один бинарник, можно его запустить нацелевой ОС, и ему не нужно ничего больше.

Про garbage collector:

- В Go вы не пишете самостоятельно `malloc()`/`free()` (как в С). Вы просто создаете переменные, и когда они перестают быть нужны, Go-рантайм сам решает, когда их удалить.
- GC отслеживает, какие объекты «достижимы» (есть ссылки), а какие — нет. И периодически (по разным триггерам) запускает цикл очистки ненужных объектов.

### Объяснение «с нуля»

1. **Что такое рантайм (runtime) в Go**

   - Когда вы запускаете программу, нужно, чтобы работал не только код, который вы сами написали (функция `main`), но и инфраструктура, которая реализует:

     - Планировщик горутин (горутин в Go — это как очень легкие потоки, благодаря которым можно писать параллельный и асинхронный код).
     - Сборщик мусора (garbage collector), который занимается очисткой ненужных участков памяти.
     - Базовая поддержка для `map`, `slice`, `struct`, `interface`, оконечных точек каналов (channels), и т. д.
     - Другие низкоуровневые штуки: работа с системой (syscalls), cgo (если делаете вызовы к C-коду), и т. д.

2. **Статическая линковка — что это значит**

   - В языках вроде C вы обычно линкуете с системным «libc» (стандартной библиотекой) динамически: файл получился «подзависимым» от внешних библиотек — пока эти библиотеки не установлены в системе, ваш код не запустится.
   - Go-рантайм (всё, что нужно для работы Go-кода) включается **не в виде динамической библиотеки**, а прямо в ваш бинарник (ELF/PE/Mach-O). В результате получается «толстый» исполняемый файл, но самодостаточный.
   - Преимущество: не нужно думать, «а не удалили ли вдруг у меня Go-рантайм из системы?» или «на сервере есть ли нужная версия этой библиотеки».
   - Недостаток: размер бинарника (особенно если вы не убрали отладочную информацию) может быть несколько мегабайт, а в простых С-программах размер после компиляции может быть в разы меньше.

3. **Garbage Collector (GC) — как и где он работает**

   - В Go вы при создании переменных или при использовании встроенных функций работы с динамической памятью (например, `make([]int, 100)`) не управляете процессом освобождения памяти — всё это делает Go-рантайм.
   - GC (сборщик мусора) периодически просматривает, какие объекты в куче (heap) все еще «ссылаются» где-то (в каких-то переменных, на которые указывают указатели). Если объект «недостижим» (то есть ни одна переменная, ни одна горутина не держит ссылку на этот участок памяти), GC «решает», что его можно освободить.
   - GC запускается либо автоматически, когда свободной памяти в куче становится мало, либо когда общее количество выделений превышает какой-то порог. Вы как разработчик можете в коде поставить метки для профилирования, но в простом «Hello, World» это не нужно: GC включен «по умолчанию».
   - Когда вы запускаете `go build`, вместе с вашим кодом компилируется и код самого GC: все нужные инструкции для поиска и удаления «мусора» в памяти.

4. **Почему некоторые разработчики Go называют свои программы «fat binaries»**

   - FAT (толстый) бинарь означает, что в один файл включено всё: и ваш код, и рантайм, и все зависимости.
   - После `go build` размер простого «Hello, World» бинарника может быть несколько мегабайт (в зависимости от версии Go и того, включена ли отладочная информация). Для сравнения, эквивалентная программа на С в Linux может выходить меньше 100 КБ.

5. **Как это влияет на вас как на новичка**

   - Преимущество: вы не переживаете, что на сервере у кого-то не установлен Go или что версия отличается. Дали исполняемый файл — и он без проблем запустится.
   - Недостаток: размер файла не слишком мал, и если вам важно хранить программы с минимальным размером (например, встроенные системы, микроконтроллеры), Go может здесь быть не самым легким выбором.

Таким образом, в Go **вся «нога» рантайма (и сборщик мусора) вшита прямо в исполняемый файл**, что делает ваши программы самодостаточными, но при этом несколько «толстыми».

---

## 11. Итог «под капотом» на примере вашего `hello.go`

Автор сводит всё сказанное в один большой конспект. Попробую ещё раз в максимально простой форме перечислить все основные шаги «от текста до экрана», но кратко:

1. **Вы открываете текстовый редактор и создаёте файл `hello.go`.**

   - Внутри текстовый редактор показывает вам курсор, в который вы можете вводить буквы. На уровне компьютера каждая буква — один байт (или несколько байт, если это символы кириллицы, но в нашем примере англоязычные символы «Hello, World»).
   - Вы нажимаете «Сохранить» → операционная система копирует эти байты в свободное место на вашем HDD/SSD, записывает в таблицу файлов, что «эти байты принадлежат файлу `hello.go`».

2. **Вы открываете терминал (командную строку) и ставите курсор в папку с вашим `hello.go`.**

   - Когда вы вводите команду `go run hello.go`, компьютер делает следующее:

     1. Go-toolchain (утилита, установленная вместе с Go) видит: «Нужно запустить файл hello.go».
     2. Создает временный каталог, копирует туда ваш `hello.go` (HDD → RAM → HDD во временной папке).
     3. В этом временном каталоге запускает компиляцию (лексер, парсер, AST, SSA, машинный код, объектный файл) и получает временный исполняемый файл (допустим, `/tmp/go-build1234/123456/b001`).
     4. Сразу делает системный вызов (например, на Linux `fork` + `execve`) и запускает получившийся бинарник.

3. **Компьютер (ОС + CPU) «разворачивает» полученный бинарник в оперативную память (RAM)**

   1. Операционная система читает заголовок ELF и видит, куда нужно поместить секцию `.text` (код) и секцию `.rodata` (данные).
   2. Выделяет области в виртуальном адресном пространстве (RAM), куда загрузить код и данные.
   3. Устанавливает права:

      - Секция `.text` → «read + execute» (чтобы можно было исполнять инструкции, но нельзя было изменять код изнутри).
      - Секция `.rodata` → «read-only» (чтобы константы нельзя было перезаписать).
      - Секция `.data` → «read-write» (если бы там были глобальные переменные).

   4. Выделяет стек (stack) — кусок памяти, куда будут складываться адреса возврата и локальные переменные ваших функций.
   5. Выделяет область под кучу (heap) — если в программе нужны динамические выделения (в «Hello, World» они минимальны, но Go-рантайм может инициализировать какие-то регионы).
   6. Устанавливает регистр инструкций (CPU Instruction Pointer) на адрес точки входа (`_start`).

4. **CPU начинает выполнять инструкции последовательно**

   - Первые инструкции принадлежат Go-рантайму: он настраивает планировщик горутин, стартует сборщик мусора.
   - Затем Go-рантайм вызывает вашу функцию `main.main()`. Когда CPU доходит до инструкции вызова `fmt.Println`, он переходит к реализации функции `Println`.
   - Внутри `Println` собирается строка «Hello, World\n» и вызывается системный вызов ОС (например, `write(1, buf, len)`).
   - Ядро ОС берет байты из вашего буфера, перенаправляет их драйверу терминала → тот отрисовывает символы в окне терминала. Вы видите сообщение на экране.
   - Когда `Println` закончила, CPU возвращается в `main`, и там, так как больше нет команд, функция завершается.

5. **Go-рантайм завершает работу**

   - После окончания `main` Go-рантайм проверяет: «Уже ли все фоновые горутины завершены?» (в нашем примере фоновых нет).
   - Если есть какие-то открытые файлы, сетевые соединения, Go-рантайм может попытаться их закрыть (обычно это делают разработчики вручную, но Go определяет, когда нужно почистить остатки).
   - Run-time возвращает код возврата 0 операционной системе.
   - ОС отмечает процесс завершенным, освобождает всю память, открытые дескрипторы, и передает управление терминалу.

6. **Go-toolchain удаляет временный бинарник**

   - Так как вы использовали `go run`, то после того, как процесс завершился, Go-toolchain автоматически удаляет временный ELF/PE-файл из `/tmp/...`.
   - Ваша исходная папка осталась «чистой» — там только `hello.go`, никаких дополнительных артефактов.

7. **Если бы вы сделали `go build hello.go`**

   - Тогда Go-toolchain бы не удалял бинарник. Вместо этого он бы создал файл `hello` (или `hello.exe`) в той же папке, где лежат ваши `.go`-файлы.
   - Вы могли бы запускать `./hello` сколько угодно раз: ОС каждый раз бы подгружала в память и выполняла те же самые инструкции.
   - Если бы вы передали этот `hello` другому человеку с такой же операционной системой и архитектурой, он бы запустил его без установки Go.

---

## 12. Немного глубже о `fmt.Println` и поддержке строк (UTF-8, Unicode)

### Что говорится в тексте

Автор рассказывает, что в Go строка — это специальный «структурный» тип: она хранится как указатель на массив байт и длина. Байты обычно представляют собой UTF-8, поэтому Go «из коробки» поддерживает любые символы (русские буквы, китайские иероглифы, смайлики). Когда вы пишете `"Hello, World"`, Go записывает это в раздел `.rodata` вашего бинарника как набор байт UTF-8, а при вызове `fmt.Println` копирует этот набор байт в буфер, добавляет символ новой строки и делает системный вызов на запись.

### Объяснение «с нуля»

1. **Как в Go хранятся строки**

   - Строки в Go — это не просто «последовательность символов» на уровне языка. На машинном уровне это _пара_ данных:

     1. **Указатель** (адрес в памяти), где лежит первый байт строки.
     2. **Целочисленная величина** (длина), обозначающая, сколько байт в этой строке содержится.

   - Пример: если вы пишете `s := "Привет"`, то Go подсчитывает, сколько байт нужно для кодирования каждого символа в UTF-8 (а русские буквы в UTF-8 занимают по 2 байта), складывает их, и в `.rodata` закладывает эти байты. Затем переменная `s` получает два поля: указатель на начало этих байтов и длину (в нашем случае, 12 байт, потому что 6 букв × 2 байта).

2. **Зачем UTF-8**

   - UTF-8 — это способ кодировать любые символы Unicode (русский, китайский, смайлики и т. д.) с помощью одного-двух-трех байт.
   - Go по умолчанию хранит строки в формате UTF-8, поэтому, когда вы пишете `"Привет, мир!"` или `"こんにちは"` или `🙂`, Go корректно конвертирует их в нужную последовательность байт.

3. **Что делает `fmt.Println` с этой строкой**

   - `Println` в Go умеет принимать разные типы данных как аргументы (числа, строки, булевы значения, даже пользовательские структуры). Внутри она приводит всё к «представлению», которое можно вывести. В случае строки это просто:

     1. Забрать указатель и длину (т. е. взять байты из `.rodata`).
     2. Добавить в конец «символ новой строки» (`\n` — одна байтовая константа 0x0A).
     3. Вызвать системный вызов ОС (например, на Linux это `write(1, buf, length)`), где `1` — это дескриптор стандартного вывода (обычно это терминал), `buf` — указатель на байты, а `length` — сколько байт нужно записать.

4. **Как это попадает на экран**

   - Системный вызов `write(1, buf, length)` переходит в ядро Linux, ядро вызывает драйвер терминала, терминал (часть текстового интерфейса) интерпретирует байты в соответствии с UTF-8 (если ваша консоль на это настроена) и показывает символы на экране.
   - В Windows мог быть другой вызов (`WriteConsoleW` или что-то в этом духе), но принцип аналогичный: куча «нажатий» низкоуровневых инструкций, затем вызов драйвера, и в итоге вы видите текст на экране.

Итак, **когда вы пишете `fmt.Println("Hello, World")`, на самом деле происходит: сборка UTF-8 байтов, добавление `\n`, системный вызов на запись, и «рисование» символов терминалом».**

---

## 13. Резюме «что происходит» при `go run hello.go`

Автор в самом конце приводит «краткий конспект» — еще раз перечисляет весь путь «от текста до экрана». Давайте ещё раз кратко:

1. **Пишем файл `hello.go` и сохраняем его на диске (HDD/SSD)**

   - Байты с текстом из редактора → через файловую систему → на диск.

2. **Запускаем `go run hello.go` в терминале**

   1. Go-toolchain создаёт временную папку.
   2. Копирует туда `hello.go` (HDD → RAM → HDD (во временной папке)).
   3. Компилирует код: лексинг → парсинг → AST → SSA → машинные инструкции → объектный файл.
   4. Линкует с пакетом `fmt` и рантаймом.
   5. Создает временный бинарник (ELF/PE) и кладёт его тоже во временную папку.
   6. Запускает временный бинарник, используя системный вызов ОС (fork+execve или CreateProcess).

3. **Операционная система загружает бинарник в память**

   1. Читает заголовок ELF/PE → решает, куда в виртуальном адресном пространстве поместить секцию `.text`, `.data`, `.rodata`, `stack`, `heap`.
   2. Помечает память под код как «исполняемую» и под данные как «чтение/запись».
   3. Помещает указатель инструкций на стартовую функцию рантайма Go.

4. **CPU начинает исполнять машинный код**

   1. Go-рантайм инициализируется (планировщик горутин, сборщик мусора).
   2. Рантайм вызывает `main.main()`.
   3. Внутри `main` встречает `fmt.Println`, формирует строку и делает системный вызов ОС (например, `write(1, buf, len)`).
   4. ОС записывает байты в буфер терминала, а терминал отображает символы на экране — вы видите «Hello, World».
   5. `main` завершилась, Go-рантайм автоматически завершает все фоновые горутины, освобождает ресурсы, возвращает ОС код 0.
   6. Процесс «умирает».

5. **Go-toolchain после завершения удаляет временный бинарник**

   - Если это был `go run`, то временный файл убирается, и у вас в рабочей папке остаётся только `hello.go`.

6. **Если это был `go build hello.go`, то временная папка не создаётся**, а вместо этого ваша готовая программа `hello` (`hello.exe` в Windows) оказывается прямо в той папке, где лежал `hello.go`.

Таким образом, **полный «путь» выглядит так:**

```
Текст в редакторе → HDD/SSD
   → go run: копируем в /tmp → лексинг → парсинг → SSA → машинный код → линковка → бинарник во /tmp → execve → загрузка в RAM → CPU выполняет → «Hello, World» на экране → завершение → удаление /tmp
   → go build: HDD/SSD → лексинг → парсинг → SSA → машинный код → линковка → бинарник в вашей папке → при запуске ОС загрузит его в RAM → CPU выполняет → «Hello, World» на экране → завершение
```

---

## 14. Совет для дальнейшего изучения

В самом конце автор даёт несколько практических рекомендаций, что делать дальше:

1. **Измените текст и повторите**

   - Вместо `"Hello, World"` напишите, например, `"Привет, мир!"`, сохраните и снова запустите (`go run hello.go`). Убедитесь, что Go корректно отображает кириллицу (UTF-8).

2. **Добавьте простые вычисления**

   - Например, в `func main()` напишите:

     ```go
     a := 1 + 2
     fmt.Println("Сумма:", a)
     ```

     Сохраните, запустите — увидите, как Go сначала вычисляет `1 + 2`, кладет результат в переменную `a`, а потом «fmt.Println» выводит «Сумма: 3».

   - Если вы совершите синтаксическую ошибку (например, пропустите двоеточие или скобку), компилятор «захнычет» и укажет, в какой строке ошибка.

3. **Попробуйте разбить код на несколько файлов**

   - Создайте рядом `utils.go`, где напишите:

     ```go
     package main

     func sayHi() {
         fmt.Println("Hi!")
     }
     ```

     А в `hello.go` напишите:

     ```go
     package main

     import "fmt"

     func main() {
         sayHi()
         fmt.Println("Hello from main")
     }
     ```

     Сохраните оба файла и запустите `go run hello.go` (или `go build`). Компилятор поймет, что оба файла в одной папке и с `package main`, объединит их, и в итоге вы увидите, как сначала выполнится `sayHi()`, а потом — остальной код.

4. **Поиграйте с пакетами и модулями**

   - Если вы хотите вынести «свою библиотеку» в отдельную папку, сделайте так:

     ```
     myproject/
       ├── hello.go
       └── mylib/
           └── mylib.go
     ```

     Внутри `mylib.go`:

     ```go
     package mylib

     import "fmt"

     func SayHello() {
         fmt.Println("Hello from mylib")
     }
     ```

     А в `hello.go`:

     ```go
     package main

     import (
         "fmt"
         "myproject/mylib" // предполагаем, что вы находитесь внутри GOPATH или используете go.mod
     )

     func main() {
         mylib.SayHello()
         fmt.Println("Back in main")
     }
     ```

     При этом нужно позаботиться о `go.mod` — файле, который управляет зависимостями в Go. Но об этом можно узнать позже, когда вы освоитесь с базовыми понятиями.

5. **Углубитесь в работу GC, горутин и профилирование**

   - Сможете писать небольшие программы, которые создают горутины (например, `go func() { … }()`) и наблюдать, как Go-рантайм распределяет их по ядрам процессора.
   - Посмотрите, как Go-рантайм отслеживает объекты в памяти и когда запускается GC. Для этого можно включить специальные флаги при запуске, но это уже чуть более продвинутые темы.

---

### Краткий вывод для абсолютного новичка

1. **Компьютер хранит файлы как последовательность байтов на диске**. Когда вы создаёте `hello.go`, вы сохраняете текст в файл на HDD/SSD.
2. **Чтобы Go-компилятор знал, что это код именно на Go, файл должен иметь расширение `.go`**.
3. **Каждый `.go`-файл начинается с `package main`, если вы хотите получить исполняемую программу**.
4. **Каждая программа на Go должна иметь функцию `func main()`, откуда ОС начинает её выполнение**.
5. **Когда вы запускаете `go run hello.go`, Go-утилита компилирует и запускает ваш код «под капотом»**: читается файл → лексинг → парсинг → проверка типов → оптимизация → генерация машинного кода → линковка с пакетом `fmt` и Go-рантаймом → полученный бинарник запускается CPU.
6. **Когда вы запускаете `go build hello.go`, вместо временного запуска Go создает готовый файл `hello` (или `hello.exe`), который можно запускать многократно**.
7. **Внутри бинарника Go-рантайм (включая сборщик мусора и планировщик горутин) уже «вшит» статически**, поэтому вам не нужно ставить Go на сервере, чтобы программа работала.

Понимая все эти шаги, вы начинаете видеть, как «простой текст» превращается в инструкции, которые реально исполняет ваш процессор, как взаимодействие с операционной системой и файловой системой происходит «за кулисами», и что происходит, когда вы просто печатаете команду `go run hello.go`.

**Надеюсь, такая подробная «расшифровка» вашего текста поможет вам понять, как работает компилятор Go, линковщик, операционная система и процессор вместе. Удачи в изучении программирования и устройству компьютеров!**
