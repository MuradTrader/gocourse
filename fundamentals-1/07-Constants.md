Разберём каждую строчку твоего текста максимально подробно, с самыми простыми примерами и аналогиями. Представь, что компьютер — это огромный дом, а память — это его комнаты и шкафы, где хранятся разные вещи. Биты и байты — это крошечные лампочки (бит) и наборы из 8 лампочек (байт), которые либо горят (`1`), либо не горят (`0`).

---

## 1. Что такое константы и зачем они нужны

> **Константа** — это **неменяемое** («immutable») значение, известное **на этапе компиляции** и **не меняющееся** во время работы программы.

1. **Неменяемое**

   - Представь табличку на дверце шкафа: на ней написано «Здесь хранится π = 3.14», и больше никто не может стереть или переписать эту табличку.

2. **Известное на этапе компиляции**

   - Компилятор (рабочий по сборке кода) ещё до запуска программы читает: «Ах, тут у нас `Pi = 3.14`», и запоминает это навсегда.

3. **Не меняется во время работы**

   - При выполнении программы никакие функции или операции не смогут зайти в эту «ячейку» и переписать её на другое значение.

> **Используются для “магических” чисел и строк**: π, скорость свободного падения, ключи конфигурации и т.д.

- **Пример**:

  ```go
  const Pi = 3.14159
  const AppName = "MyGreatApp"
  ```

  Если бы ты везде вместо `Pi` писал `3.14159`, было бы трудно понять, что за число. А с `Pi` сразу понятно.

> **Константы** улучшают читаемость и защищают от случайного изменения.

- **Почему это важно**:

  - Читаешь код и сразу видишь смысл переменной `Gravity` — это ускорение свободного падения, а не какая-то случайная цифра `9.81`.

---

## 2. Объявление констант: синтаксис и варианты

### 2.1. Простой вариант

```go
const Pi = 3.14
const Gravity = 9.81
```

- Здесь `Pi` и `Gravity` — **untyped** (неявно типизированные) константы.
- **Как это работает**:

  - Компилятор хранит внутри точное значение `3.14` (например, как большую дробь с десятками бит точности).
  - Когда ты используешь `Pi` в коде, он сам решает, нужен ли там `float32` или `float64`, и делает подстановку.

### 2.2. Явный тип

```go
const (
    MaxUsers int    = 100
    AppName  string = "MyApp"
)
```

1. `MaxUsers int = 100`

   - Мы говорим: «MaxUsers — это **целое число** (`int`), и в нём лежит `100`.»
   - **Проверка**: компилятор убедится, что `100` — действительно целое и помещается в `int`.

2. `AppName string = "MyApp"`

   - Тут явно указываем тип `string` и значение `"MyApp"`.

### 2.3. Группировка — «const block»

```go
const (
    Monday = iota + 1  // iota=0 → Monday=1
    Tuesday            // iota=1 → Tuesday=2
    Wednesday          // iota=2 → Wednesday=3
)
```

- `iota` — специальная переменная-счётчик, которая в каждой группе `const(...)` начинает с `0` и автоматически увеличивается на `1` при каждом новом имени.
- **Почему `+1`?** Потому что по умолчанию `iota` даёт `0` для `Monday`, но мы хотим, чтобы понедельник считался с `1`.

### 2.4. CamelCase или UPPER_SNAKE_CASE?

- В Go **не обязательно** писать `MAX_USERS` большими буквами. Обычно используют `MaxUsers` (CamelCase).
- Важно договориться в команде и всегда следовать одному стилю.

---

## 3. «Под капотом»: как компилятор обрабатывает константы

1. **Известны на этапе компиляции**

   - При встрече `const Pi = 3.14` компилятор **не** создаёт в памяти ячейку для `Pi`.
   - Вместо этого, везде, где встречается `Pi`, он **подставляет** буквально `3.14` в сгенерированный код.

2. **Zero memory footprint**

   - В итоговом исполняемом файле (bинарнике) **нет** отдельной секции `.data` или `.bss` под `Pi`.
   - Если ты нигде не используешь `Gravity`, то и `9.81` в финальный код не попадёт.

3. **Typed vs untyped**

   - **Untyped** константа хранится внутри компилятора как «большая точная дробь».
   - Когда ты делаешь:

     ```go
     var x float32 = Pi
     ```

     компилятор вставляет в код что-то вроде `MOV x, float32(3.14)`.

   - **Typed** константа сразу проверяется и превращается в нужный тип: `const A int = 5` — компилятор запомнил, что `A` уже `int`.

---

## 4. Чем константы отличаются от переменных

| Свойство                  | Переменная (`var`)                        | Константа (`const`)                                   |
| ------------------------- | ----------------------------------------- | ----------------------------------------------------- |
| **Изменяемость**          | можно менять значение                     | нельзя (компилятор запретит)                          |
| **Место хранения**        | в `.data`/`.bss` (глобально) или на стеке | **не хранится** отдельно — подставляется в код        |
| **Инициализация**         | zero value или выражение                  | **только** выражение, вычисляемое на этапе компиляции |
| **Короткая форма (`:=`)** | можно внутри функций                      | **нельзя** — только `const`                           |
| **Type inference**        | с `:=` и `var x =`                        | да, для untyped                                       |

**Аналогия**:

- **Переменная** — это ящик, в который ты можешь класть и откуда доставать предметы.
- **Константа** — табличка на стене со значением, её нельзя снять или переписать.

---

## 5. Правила и нюансы использования

1. **Компилируемые выражения**

   - Константа может быть только:

     - Литералом: `1`, `"abc"`, `true`.
     - Выражением из других констант: `A + 2`, `1 << (10*iota)`.

   - **Нельзя** вызывать произвольные функции в `const`.

     ```go
     const C = time.Now().Unix() // ОШИБКА: в константах нельзя вызывать функции
     ```

2. **Примеры недопустимого**

   - `const X = rand.Int()` — нельзя, потому что `rand.Int()` выполняется во время работы.
   - `const Y = someVar + 1` — `someVar` не известна на этапе компиляции.

3. **Групповые определения и `iota`**

   ```go
   const (
     _  = iota              // 0 (пропускаем)
     KB = 1 << (10 * iota)  // 1<<10 = 1024
     MB                      // 1<<20 = 1_048_576
     GB                      // 1<<30 = 1_073_741_824
   )
   ```

   — удобно для задания размеров в байтах.

4. **Использование в `switch`/`case`**

   ```go
   switch day {
   case Monday, Tuesday:
       fmt.Println("Начало недели")
   case Wednesday:
       fmt.Println("Середина недели")
   }
   ```

   Константы делают код понятным: `case 1, 2` заменяется на `case Monday, Tuesday`.

---

## 6. Зачем так делать: выгоды констант

1. **Производительность**

   - CPU сразу видит нужное число в инструкции, без лишних чтений из оперативной памяти (байт — быстро, а чтение из памяти — чуть медленнее).

2. **Надёжность**

   - Нельзя случайно перезаписать: если ты попытаешься — компилятор скажет «Ошибка: нельзя менять константу».

3. **Поддерживаемость**

   - Все важные «магические» числа и строки собраны в одном месте, и понятно, что они означают.

4. **Оптимизация бинарника**

   - Неиспользуемые константы вообще не попадут в собранный файл — он останется компактным.

---

### Итоговая картинка «под капотом»

1. Ты пишешь `const Pi = 3.14`.
2. Компилятор читает и запоминает: «Pi → 3.14».
3. При «складе вещей» (оптимизация) удаляет любые невостребованные константы.
4. При генерации машинного кода везде вместо `Pi` пишет просто `3.14` (или соответствующий Immediate-операнд в инструкции).
5. В итоговом исполняемом файле **нет** отдельного места под `Pi` — только твои инструкции, где `3.14` уже вписано заранее.

Надеюсь, теперь каждая строчка твоего текста стала прозрачнее. Если хочешь ещё больше деталей про биты/байты или как работают другие конструкции, пиши — разберём!
