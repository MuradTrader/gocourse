## Шаг 1: Что такое направления каналов (Channel Directions)

Направления каналов определяют допустимые операции с каналом: либо отправка, либо получение. Они используются для контроля и документирования предполагаемого использования каналов в функциях и горутинах.

**Важно:** Направления каналов предназначены для использования в функциях и горутинах, а не как независимые переменные.

## Шаг 2: Зачем нужны направления каналов?

1. Улучшают ясность и поддерживаемость кода
2. Предотвращают непреднамеренные операции с каналами
3. Улучшают типобезопасность, четко определяя назначение канала

## Шаг 3: Двунаправленные и однонаправленные каналы

По умолчанию канал **двунаправленный** (bidirectional). Мы можем превратить его в **однонаправленный** (unidirectional), используя оператор стрелки (`<-`):

- **Канал только для отправки** (send-only): стрелка ПЕРЕД `chan` → `chan<- тип`
- **Канал только для получения** (receive-only): стрелка ПОСЛЕ `chan` → `<-chan тип`

## Шаг 4: Пример с каналом только для отправки

```go
package main

import "fmt"

func main() {
    channel := make(chan int)  // Двунаправленный канал

    go func(sendCh chan<- int) {  // Параметр: канал только для отправки
        for i := 0; i < 5; i++ {
            sendCh <- i  // Отправляем значение
        }
        close(sendCh)  // Закрываем канал после отправки
    }(channel)  // Передаем двунаправленный канал как аргумент

    // Получаем значения из канала
    for value := range channel {
        fmt.Println("Received", value)
    }
}
```

**Результат в консоли:**

```
Received 0
Received 1
Received 2
Received 3
Received 4
```

## Шаг 5: Объяснение примера

1. Создаем двунаправленный канал `channel`
2. Запускаем горутину с функцией, принимающей канал только для отправки
3. Передаем двунаправленный канал `channel` в эту функцию
4. Внутри функции можем только отправлять в канал, но не получать из него
5. Закрываем канал после отправки всех значений
6. В главной горутине получаем значения из канала

## Шаг 6: Пример с каналом только для получения

```go
package main

import "fmt"

// Функция принимает канал только для получения
func receiveData(receiveCh <-chan int) {
    for value := range receiveCh {
        fmt.Println("Received", value)
    }
}

func main() {
    channel := make(chan int)  // Двунаправленный канал

    go func(sendCh chan<- int) {  // Канал только для отправки
        for i := 0; i < 5; i++ {
            sendCh <- i
        }
        close(sendCh)
    }(channel)

    // Передаем канал в функцию, которая принимает канал только для получения
    receiveData(channel)
}
```

**Результат в консоли:**

```
Received 0
Received 1
Received 2
Received 3
Received 4
```

## Шаг 7: Что происходит

1. Функция `receiveData` принимает канал только для получения (`<-chan int`)
2. Внутри нее можно только читать из канала, но не отправлять в него
3. Мы передаем двунаправленный канал в эту функцию - это допустимо
4. Но внутри функции канал становится "только для получения"

## Шаг 8: Попытка использовать неправильное направление

```go
package main

import "fmt"

func main() {
    // Попытка создать канал только для получения
    var receiveCh <-chan int = make(<-chan int)

    // ОШИБКА: нельзя отправлять в канал только для получения
    receiveCh <- 1

    fmt.Println("This won't print")
}
```

**Компилятор выдаст ошибку:** невозможно отправить в канал только для получения.

## Шаг 9: Паттерн Producer-Consumer (Производитель-Потребитель)

```go
package main

import "fmt"

// Producer - функция, которая только отправляет данные
func producer(sendCh chan<- int) {
    for i := 0; i < 5; i++ {
        sendCh <- i
    }
    close(sendCh)
}

// Consumer - функция, которая только получает данные
func consumer(receiveCh <-chan int) {
    for value := range receiveCh {
        fmt.Println("Received", value)
    }
}

func main() {
    channel := make(chan int)  // Двунаправленный канал

    go producer(channel)  // Запускаем производителя
    consumer(channel)     // Запускаем потребителя
}
```

**Результат в консоли:**

```
Received 0
Received 1
Received 2
Received 3
Received 4
```

## Шаг 10: Что нельзя сделать

```go
package main

func main() {
    // Так делать НЕЛЬЗЯ - бессмысленно
    sendOnly := make(chan<- int)
    receiveOnly := make(<-chan int)

    // sendOnly <- 1  // Нельзя отправить - нет получателя
    // <-receiveOnly  // Нельзя получить - нет отправителя
}
```

## Шаг 11: Полный рабочий пример

```go
package main

import "fmt"

// Функция-производитель (только отправляет)
func produce(sendCh chan<- int) {
    for i := 0; i < 3; i++ {
        fmt.Printf("Producing: %d\n", i)
        sendCh <- i
    }
    close(sendCh)
}

// Функция-потребитель (только получает)
func consume(receiveCh <-chan int) {
    for value := range receiveCh {
        fmt.Printf("Consuming: %d\n", value)
    }
}

func main() {
    dataChannel := make(chan int)  // Двунаправленный канал

    go produce(dataChannel)  // Передаем канал производителю
    consume(dataChannel)     // Передаем тот же канал потребителю

    fmt.Println("Done")
}
```

**Результат в консоли:**

```
Producing: 0
Consuming: 0
Producing: 1
Consuming: 1
Producing: 2
Consuming: 2
Done
```

## Шаг 12: Почему это важно

```go
package main

import "fmt"

// ПЛОХО: функция может делать с каналом что угодно
func badFunction(ch chan int) {
    ch <- 1      // Отправляет
    val := <-ch  // Получает
    close(ch)    // Закрывает
    // ... и все в одной функции
}

// ХОРОШО: функция имеет четкое назначение
func goodSender(ch chan<- int) {
    ch <- 1
    // Не может получать или случайно закрыть
}

func goodReceiver(ch <-chan int) int {
    val := <-ch
    return val
    // Не может отправлять или закрывать
}

func main() {
    ch := make(chan int, 1)

    go goodSender(ch)
    result := goodReceiver(ch)
    fmt.Println("Result:", result)
}
```

**Результат в консоли:**

```
Result: 1
```

## Шаг 13: Ключевые выводы

### 1. **Типы каналов:**

- `chan T` - двунаправленный (отправка и получение)
- `chan<- T` - только для отправки (send-only)
- `<-chan T` - только для получения (receive-only)

### 2. **Правила:**

- Двунаправленный канал может быть передан в функцию, ожидающую однонаправленный канал
- Однонаправленный канал НЕ может быть передан в функцию, ожидающую двунаправленный канал
- Однонаправленные каналы имеют смысл только в параметрах функций

### 3. **Преимущества:**

- **Безопасность:** предотвращает случайные операции
- **Читаемость:** сразу понятно назначение канала в функции
- **Поддержка:** упрощает рефакторинг и понимание кода

### 4. **Паттерны использования:**

- **Producer:** `func producer(ch chan<- T)`
- **Consumer:** `func consumer(ch <-chan T)`
- **Pipeline:** цепочка функций, передающих каналы с разными направлениями

## Выводы из текста:

1. **Направления каналов** используются для указания, может ли функция отправлять или получать данные
2. **Двунаправленные каналы** создаются с помощью `make(chan тип)`
3. **Однонаправленные каналы** имеют смысл только в сигнатурах функций
4. **Производитель-потребитель** - основной паттерн использования направлений каналов
5. **Направления улучшают безопасность** и ясность кода
