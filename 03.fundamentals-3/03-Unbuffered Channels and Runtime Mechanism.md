Я буду максимально подробно объяснять шаг за шагом, как в курсе, и показывать результаты выполнения кода.

## Шаг 1: Что такое небуферизованные каналы (Unbuffered Channels)

В предыдущих примерах мы создавали небуферизованные каналы:

```go
greeting := make(chan string)  // Это небуферизованный канал
```

**Небуферизованный канал** - это канал без хранилища. Он должен немедленно передавать значения от отправителя к получателю.

## Шаг 2: Что такое буферизованные каналы (Buffered Channels)

**Буферизованный канал** - это канал с хранилищем (буфером). Он может хранить ограниченное количество значений до того, как отправитель будет заблокирован.

## Шаг 3: Зачем нужны буферизованные каналы

Основное отличие: буферизованные каналы позволяют **асинхронную коммуникацию**. Отправитель может продолжать работу, не блокируясь, пока буфер не заполнится.

## Шаг 4: Поведение небуферизованных каналов

Давайте снова посмотрим на пример с небуферизованным каналом:

```go
package main

import "fmt"

func main() {
    ch := make(chan int)  // Небуферизованный канал

    ch <- 1  // Пытаемся отправить значение

    receiver := <-ch  // Пытаемся получить значение
    fmt.Println(receiver)
}
```

**Результат в консоли:**

```
fatal error: all goroutines are asleep - deadlock!
```

## Шаг 5: Почему ошибка?

Небуферизованный канал требует **немедленного получателя**. Как только мы отправляем значение в канал, он сразу ищет получателя. В данном случае получатель находится на следующей строке, но канал не может ждать так долго.

## Шаг 6: Правильный способ с горутиной

```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        ch <- 1  // Отправляем в горутине
    }()

    receiver := <-ch  // Получаем в главной горутине
    fmt.Println(receiver)
}
```

**Результат в консоли:**

```
1
```

## Шаг 7: Аналогия с каналом

Представьте канал как:

- Наклоненную трубу (вода течет сверху вниз)
- Горку на детской площадке
- Конвейерную ленту

Небуферизованный канал не может хранить значения - он должен немедленно передавать их.

## Шаг 8: Что происходит внутри

1. Главная горутина создает канал
2. Запускает анонимную горутину
3. Главная горутина блокируется на получении (`<-ch`)
4. Анонимная горутина отправляет значение в канал
5. Главная горутина получает значение и продолжает работу

## Шаг 9: Если поменять местами

```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    // Отправляем в главной горутине
    ch <- 1

    // Получаем в другой горутине
    go func() {
        receiver := <-ch
        fmt.Println(receiver)
    }()
}
```

**Результат в консоли:**

```
fatal error: all goroutines are asleep - deadlock!
```

**Почему ошибка?** Отправка в главной горутине блокируется, ожидая получателя. Но получатель в другой горутине не успевает запуститься.

## Шаг 10: Небуферизованный канал с ожиданием

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    go func() {
        time.Sleep(2 * time.Second)  // Ждем 2 секунды
        ch <- 1
        fmt.Println("Отправил значение")
    }()

    receiver := <-ch  // Блокируемся, пока не получим значение
    fmt.Println("Получил:", receiver)
}
```

**Результат в консоли (через 2 секунды):**

```
Получил: 1
Отправил значение
```

## Шаг 11: Несколько горутин

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    go func() {
        time.Sleep(2 * time.Second)
        fmt.Println("2 секундная горутина завершена")
    }()

    go func() {
        time.Sleep(3 * time.Second)
        fmt.Println("3 секундная горутина завершена")
    }()

    receiver := <-ch  // Ждем значение из канала
    fmt.Println("Получил:", receiver)
    fmt.Println("Конец программы")
}
```

**Результат в консоли:**

```
(ждет 2 секунды, затем выводит)
2 секундная горутина завершена
(ждет еще 1 секунду, затем выводит)
3 секундная горутина завершена
(программа продолжает ждать, потому что канал пуст)
```

Программа ждет получения значения из канала, но его никто не отправляет.

## Шаг 12: Отправка значения

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    go func() {
        ch <- 1  // Отправляем сразу
        time.Sleep(3 * time.Second)
        fmt.Println("3 секундная горутина завершена")
    }()

    receiver := <-ch  // Получаем сразу
    fmt.Println("Получил:", receiver)
    fmt.Println("Конец программы")
}
```

**Результат в консоли:**

```
Получил: 1
Конец программы
(программа завершается, не дожидаясь горутины)
```

## Шаг 13: Получатель в горутине

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    // Получатель в горутине
    go func() {
        time.Sleep(3 * time.Second)
        receiver := <-ch  // Получаем из канала
        fmt.Println("Получил в горутине:", receiver)
    }()

    // Отправляем в главной горутине (Не буферизованные каналы блокируют отправку, пока не получит получателя)
    ch <- 1
    fmt.Println("Отправил значение")
    fmt.Println("Конец программы")
}
```

**Результат в консоли:**

```
Получил в горутине: 1
Отправил значение
Конец программы
```

## Шаг 14: Ожидание горутины

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    go func() {
        time.Sleep(3 * time.Second)
        receiver := <-ch  // Получаем из канала
        fmt.Println("Получил в горутине:", receiver)
    }()

    ch <- 1  // Отправляем значение
    fmt.Println("Отправил значение")

    time.Sleep(4 * time.Second)  // Ждем завершения горутины
    fmt.Println("Конец программы")
}
```

**Результат в консоли:**

```
(ждет 3 секунды)
Получил в горутине: 1
Отправил значение
(ждет еще 1 секунду)
Конец программы
```

## Шаг 15: Ключевые свойства небуферизованных каналов

1. **Блокировка при отправке**: если нет соответствующей операции получения
2. **Блокировка при получении**: если нет соответствующей операции отправки
3. **Требуют синхронизации**: отправитель и получатель должны быть готовы одновременно

## Шаг 16: Еще один пример для понимания

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    fmt.Println("Начало программы")

    go func() {
        fmt.Println("Горутина: начинаю спать")
        time.Sleep(2 * time.Second)
        fmt.Println("Горутина: просыпаюсь и отправляю значение")
        ch <- 42
        fmt.Println("Горутина: значение отправлено")
    }()

    fmt.Println("Основной поток: жду значение из канала")
    value := <-ch
    fmt.Printf("Основной поток: получил значение %d\n", value)

    time.Sleep(1 * time.Second)
    fmt.Println("Конец программы")
}
```

**Результат в консоли:**

```
Начало программы
Основной поток: жду значение из канала
Горутина: начинаю спать
(ждет 2 секунды)
Горутина: просыпаюсь и отправляю значение
Горутина: значение отправлено
Основной поток: получил значение 42
(ждет 1 секунду)
Конец программы
```

## Выводы из текста:

1. **Небуферизованные каналы** создаются с помощью `make(chan тип)`
2. **Они требуют немедленного получателя** при отправке
3. **Блокируют выполнение** до тех пор, пока не будет готов получатель/отправитель
4. **Работают только между горутинами** - нужна как минимум одна дополнительная горутина
5. **Главная функция тоже является горутиной** (main goroutine)
6. **Канал не может хранить значения** - только передавать их
7. **Отправка блокируется**, если нет получателя
8. **Получение блокируется**, если нет отправителя

В следующей части мы перейдем к буферизованным каналам, которые могут хранить несколько значений.
