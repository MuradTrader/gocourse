## **Разбор кода ПОСТРОЧНО**

### **1. Объявление пакета и импорты**

```go
package main
```

- `package` - ключевое слово Go для объявления пакета
- `main` - специальное имя пакета. Точка входа в программу. В Go каждая программа должна иметь пакет `main` с функцией `main()`.

```go
import (
    "errors"
    "fmt"
)
```

- `import` - ключевое слово для подключения других пакетов
- `()` - скобки для импорта нескольких пакетов (group import)
- `"errors"` - стандартный пакет Go для работы с ошибками
- `"fmt"` - стандартный пакет для форматированного ввода/вывода (аналог printf в C)

**Что происходит под капотом:** Компилятор ищет эти пакеты в:

1. Стандартной библиотеке Go (`/usr/local/go/src/...`)
2. Указанных в `GOPATH`
3. Модулях Go (`go.mod`)

---

### **2. Объявление структуры CustomError**

```go
type CustomError struct {
    Code    int
    Message string
    Err     error
}
```

**Построчно:**

#### **Строка 1:**

```go
type CustomError struct {
```

- `type` - ключевое слово для создания нового типа
- `CustomError` - имя нового типа (начинается с заглавной буквы = экспортируется)
- `struct` - ключевое слово, означающее "структура" (набор полей)

**Аналогия:** Это как создать чертеж (шаблон) для коробки, в которой будут храниться данные об ошибке.

#### **Строка 2:**

```go
    Code    int
```

- `Code` - имя поля структуры (начинается с заглавной = экспортируется)
- `int` - тип поля. `int` в Go может быть 32 или 64 бита в зависимости от системы

**Что хранится в памяти:**

```
[8 байт для Code]
```

#### **Строка 3:**

```go
    Message string
```

- `Message` - имя поля
- `string` - тип "строка". В Go строка это:
  - Указатель на массив байт (8 байт)
  - Длина строки (8 байт)
  - Итого: 16 байт на 64-битной системе

**Пример в памяти:**

```go
Message = "hello"
// В памяти:
// [указатель: 0x12345678] [длина: 5]
```

#### **Строка 4:**

```go
    Err     error
```

- `Err` - имя поля
- `error` - тип интерфейса. Интерфейс в Go это:
  - Указатель на информацию о типе (8 байт)
  - Указатель на данные (8 байт)
  - Итого: 16 байт

**Итоговый размер структуры:**

```
CustomError = 8(Code) + 16(Message) + 16(Err) = 40 байт
```

---

### **3. Метод Error() для структуры**

```go
func (e *CustomError) Error() string {
    return fmt.Sprintf("Error %d: %s, %v", e.Code, e.Message, e.Err)
}
```

#### **Строка 1:**

```go
func (e *CustomError) Error() string {
```

- `func` - ключевое слово для объявления функции
- `(e *CustomError)` - **получатель метода (receiver)**. Разберем подробно:
  - `e` - имя переменной, которая будет доступна внутри метода
  - `*CustomError` - тип "указатель на CustomError"
  - Зачем `*` (указатель)? Потому что:
    - Эффективнее (8 байт вместо 40)
    - Позволяет изменять оригинальную структуру

**Аналогия:**

- `(e CustomError)` - дать копию коробки с данными
- `(e *CustomError)` - дать адрес, где лежит коробка

- `Error()` - имя метода. Должно быть именно `Error()` для реализации интерфейса `error`
- `string` - возвращаемый тип (метод должен возвращать строку)

#### **Строка 2:**

```go
    return fmt.Sprintf("Error %d: %s, %v", e.Code, e.Message, e.Err)
```

- `return` - возвращает значение из функции
- `fmt.Sprintf` - функция, которая форматирует строку (как printf в C)
- `"Error %d: %s, %v"` - форматная строка:
  - `%d` - будет заменено на целое число (e.Code)
  - `%s` - будет заменено на строку (e.Message)
  - `%v` - будет заменено на значение (e.Err) с вызовом его метода Error(), если это ошибка
- `e.Code` - обращение к полю Code структуры
- `e.Message` - обращение к полю Message
- `e.Err` - обращение к полю Err

**Что происходит при вызове:**

```go
err := &CustomError{Code: 500, Message: "Ошибка", Err: nil}
fmt.Println(err) // Неявно вызывает err.Error()
```

---

### **4. Вспомогательная функция doSomethingElse()**

```go
func doSomethingElse() error {
    return errors.New("internal error")
}
```

#### **Строка 1:**

```go
func doSomethingElse() error {
```

- `doSomethingElse` - имя функции
- `()` - пустые скобки = функция без параметров
- `error` - возвращаемый тип (интерфейс ошибки)

#### **Строка 2:**

```go
    return errors.New("internal error")
```

- `errors.New` - функция из пакета `errors`
- `"internal error"` - строка, которая станет сообщением ошибки

**Что делает `errors.New()` под капотом:**

```go
// Примерная реализация:
func New(text string) error {
    return &errorString{text} // Создает указатель на структуру
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

---

### **5. Основная функция doSomething()**

```go
func doSomething() error {
    err := doSomethingElse()
    if err != nil {
        return &CustomError{
            Code:    500,
            Message: "Something went wrong",
            Err:     err,
        }
    }
    return nil
}
```

#### **Строка 1:**

```go
func doSomething() error {
```

- Объявление функции `doSomething`, которая возвращает `error`

#### **Строка 2:**

```go
    err := doSomethingElse()
```

- `err` - объявление новой переменной
- `:=` - оператор короткого объявления (объявляет и инициализирует)
- `doSomethingElse()` - вызов функции, которая ВСЕГДА возвращает ошибку

**Что происходит в памяти:**

1. Вызывается `doSomethingElse()`
2. Она создает ошибку `&errorString{"internal error"}`
3. Эта ошибка присваивается переменной `err`

#### **Строка 3:**

```go
    if err != nil {
```

- `if` - условный оператор
- `err != nil` - проверка: "переменная err НЕ равна nil"
- В Go `nil` для интерфейса означает "отсутствие значения"

**Почему эта проверка работает:**

```go
var err error = nil
// В памяти: [указатель на тип: nil] [указатель на данные: nil]

err = errors.New("test")
// В памяти: [указатель на тип: 0x1234] [указатель на данные: 0x5678]
```

#### **Строки 4-9:**

```go
        return &CustomError{
            Code:    500,
            Message: "Something went wrong",
            Err:     err,
        }
```

- `return` - возврат из функции
- `&CustomError{...}` - создание указателя на структуру CustomError с инициализацией полей
- `Code: 500` - инициализация поля Code
- `Message: "Something went wrong"` - инициализация поля Message
- `Err: err` - инициализация поля Err значением из переменной err

**Что создается в памяти:**

```
1. Создается CustomError на heap (куче):
   CustomError{
       Code: 500,
       Message: "Something went wrong" (строка создается в памяти)
       Err: [указатель на ошибку из doSomethingElse]
   }

2. Берется адрес этой структуры: &CustomError...
```

#### **Строка 11:**

```go
    return nil
```

- `nil` - нулевое значение для интерфейса
- Эта строка никогда не выполнится, т.к. `doSomethingElse()` всегда возвращает ошибку

---

### **6. Функция main() - точка входа**

```go
func main() {
    err := doSomething()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("Operation completed successfully")
}
```

#### **Строка 1:**

```go
func main() {
```

- `main` - ОСОБАЯ функция. Точка входа программы
- Go runtime автоматически вызывает `main()` при запуске

#### **Строка 2:**

```go
    err := doSomething()
```

- Вызов `doSomething()` и сохранение результата в `err`

**Цепочка вызовов:**

```
main()
  ↓
doSomething()
  ↓
doSomethingElse() → возвращает errors.New("internal error")
  ↓
doSomething() создает CustomError с этой ошибкой внутри
  ↓
main() получает CustomError
```

#### **Строка 3:**

```go
    if err != nil {
```

- Проверка: "есть ли ошибка?"

#### **Строка 4:**

```go
        fmt.Println(err)
```

- Печать ошибки
- `fmt.Println` автоматически вызывает метод `Error()` у ошибки

**Что происходит:**

```
err имеет тип *CustomError
fmt.Println видит, что err реализует интерфейс error
Вызывает err.Error()
Получает строку: "Error 500: Something went wrong, internal error"
Выводит эту строку
```

#### **Строка 5:**

```go
        return
```

- Выход из функции `main()`
- Завершение программы

#### **Строка 7:**

```go
    fmt.Println("Operation completed successfully")
```

- Эта строка НИКОГДА не выполнится, потому что мы всегда возвращаем ошибку
- Если бы `doSomething()` вернула `nil`, выполнилась бы эта строка

---

## **ВИЗУАЛИЗАЦИЯ ПАМЯТИ**

Давайте представим, как все выглядит в памяти после выполнения:

```
# 1. Создается первая ошибка (в doSomethingElse)
0x1000: errorString{"internal error"}

# 2. Создается CustomError (в doSomething)
0x2000: CustomError {
    Code: 500 (8 байт)
    Message: "Something went wrong" (строка в 0x3000)
    Err: указатель на 0x1000
}

# 3. Переменная err в main()
err (интерфейс):
  - tab: указатель на информацию о типе *CustomError (0x4000)
  - data: указатель на CustomError (0x2000)

# 4. При печати
fmt.Println(err) → err.Error() →
  форматирует строку: "Error 500: Something went wrong, internal error"
```

---

## **ПОШАГОВОЕ ВЫПОЛНЕНИЕ ПРОГРАММЫ**

1. **Запуск программы**: Go runtime вызывает `main()`

2. **В main() строка 2**: `err := doSomething()`

   - Переход в функцию `doSomething()`

3. **В doSomething() строка 2**: `err := doSomethingElse()`

   - Переход в функцию `doSomethingElse()`

4. **В doSomethingElse() строка 2**: `return errors.New("internal error")`

   - Создается структура `errorString` с текстом "internal error"
   - Возвращается указатель на эту структуру
   - Возврат в `doSomething()`

5. **В doSomething() строка 3**: `if err != nil`

   - `err` не равен `nil` (содержит указатель на ошибку)
   - Условие истинно

6. **В doSomething() строки 4-9**: Создается `&CustomError{...}`

   - Выделяется память для `CustomError`
   - Заполняются поля:
     - `Code = 500`
     - `Message = "Something went wrong"`
     - `Err = указатель на ошибку из шага 4`
   - Возвращается указатель на эту структуру
   - Возврат в `main()`

7. **В main() строка 3**: `if err != nil`

   - `err` содержит указатель на `CustomError`
   - Условие истинно

8. **В main() строка 4**: `fmt.Println(err)`

   - `fmt.Println` получает интерфейс `error`
   - Вызывает метод `Error()` у этого интерфейса
   - Go находит, что тип `*CustomError` имеет метод `Error()`
   - Вызывает его

9. **Метод Error() строки 1-2**:

   - Получает `e` (указатель на `CustomError`)
   - Форматирует строку: берет `e.Code` (500), `e.Message`, `e.Err`
   - Для `e.Err` (который содержит ошибку "internal error") вызывает ее метод `Error()`
   - Возвращает: `"Error 500: Something went wrong, internal error"`

10. **В main() строка 5**: `return`
    - Выход из `main()`
    - Программа завершается

---

## **ОТВЕТЫ НА ВОЗМОЖНЫЕ ВОПРОСЫ**

### **1. Почему `&` перед `CustomError{...}`?**

```go
return &CustomError{...}
```

- `&` берет адрес структуры в памяти
- Без `&` возвращалась бы КОПИЯ структуры (40 байт)
- С `&` возвращается АДРЕС (8 байт) - эффективнее

### **2. Зачем `*` в `(e *CustomError)`?**

Потому что метод получает тот же тип, что мы возвращаем:

- Возвращаем: `&CustomError` (указатель)
- Метод должен работать с: `*CustomError` (указатель)

### **3. Почему `Err error`, а не `Err string`?**

Потому что мы хотим хранить ЦЕЛУЮ ОШИБКУ, а не только текст:

- `Err error` может хранить ЛЮБУЮ ошибку (со своим методом Error())
- Можно создавать цепочки ошибок

### **4. Что такое `nil`?**

`nil` в Go - это:

- Для указателей: "ни на что не указывает"
- Для интерфейсов: "не содержит значения"
- Для срезов: "пустой срез"
- Для мап: "пустая мапа"
- Для каналов: "неинициализированный канал"

### **5. Почему программа завершается после `return` в main?**

Потому что `main()` - точка входа. Если `main()` завершается - завершается вся программа.

---

## **ПРАКТИЧЕСКАЯ АНАЛОГИЯ**

Представьте, что вы менеджер в компании:

1. **`doSomethingElse()`** - как рабочий на заводе

   - Он говорит: "У меня проблема с машиной!" (возвращает ошибку)

2. **`doSomething()`** - как начальник цеха

   - Получает проблему от рабочего
   - Добавляет контекст: "Проблема в цеху №5: у рабочего проблема с машиной"
   - Возвращает боссу

3. **`main()`** - как директор завода
   - Получает отчет от начальника цеха
   - Видит проблему
   - Принимает решение остановить производство (return)

Каждый уровень добавляет свой контекст, но сохраняет оригинальную проблему.
