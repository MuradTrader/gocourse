## Подробное объяснение рекурсии в Go

### 1. Что такое рекурсия на самом деле?

**Рекурсия** — это не просто "функция вызывает себя". Это механизм, при котором:

- Каждый вызов функции создает новый **контекст выполнения** (stack frame)
- Эти контексты складываются в **стек вызовов** (call stack)
- При достижении базового случая начинается процесс **раскрутки стека** (unwinding)

```go
// Давайте посмотрим, что происходит в памяти при вызове factorial(3)
func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}

// Вызов factorial(3) создает такую цепочку:
// factorial(3) -> 3 * factorial(2)
// factorial(2) -> 2 * factorial(1)
// factorial(1) -> 1 * factorial(0)
// factorial(0) -> 1 (базовый случай!)

// Затем происходит раскрутка:
// factorial(0) возвращает 1
// factorial(1) возвращает 1 * 1 = 1
// factorial(2) возвращает 2 * 1 = 2
// factorial(3) возвращает 3 * 2 = 6
```

### 2. Детали работы стека вызовов

Каждый рекурсивный вызов создает новый **stack frame**, который содержит:

- Локальные переменные функции
- Параметры функции
- Адрес возврата (куда вернуться после выполнения)
- Другие служебные данные

```go
package main

import (
    "fmt"
    "runtime/debug"
)

func main() {
    // Узнаем глубину стека по умолчанию
    fmt.Println("Default stack size:", len(debug.Stack()))

    // Демонстрация роста стека
    deepRecursion(0, 5)
}

func deepRecursion(current, max int) {
    // Получаем текущий stack trace
    stack := debug.Stack()
    fmt.Printf("Call depth: %d, Stack frames: ~%d\n",
        current, len(stack)/1000) // примерная оценка

    if current >= max {
        return
    }
    deepRecursion(current+1, max)
}
```

### 3. Подробный разбор примера с факториалом

```go
func factorial(n int) int {
    // БАЗОВЫЙ СЛУЧАЙ (base case) - критически важная часть
    // Без него произойдет бесконечная рекурсия и stack overflow
    if n == 0 {
        return 1 // По определению, 0! = 1
    }

    // РЕКУРСИВНЫЙ СЛУЧАЙ (recursive case)
    // Здесь важно: factorial(n-1) должен приближать к базовому случаю
    // Это называется "рекурсивный спуск" (recursive descent)
    return n * factorial(n-1)
}

// Что происходит в памяти при factorial(5):
//
// СТЕК ВЫЗОВОВ (растет вниз):
// ---------------------------
// main()
//   factorial(5) - ждет factorial(4)
//     factorial(4) - ждет factorial(3)
//       factorial(3) - ждет factorial(2)
//         factorial(2) - ждет factorial(1)
//           factorial(1) - ждет factorial(0)
//             factorial(0) - возвращает 1
//           factorial(1) - возвращает 1 * 1 = 1
//         factorial(2) - возвращает 2 * 1 = 2
//       factorial(3) - возвращает 3 * 2 = 6
//     factorial(4) - возвращает 4 * 6 = 24
//   factorial(5) - возвращает 5 * 24 = 120
//
// Каждый вызов занимает ~1KB в стеке (зависит от архитектуры)
```

### 4. Глубокий анализ sumOfDigits

```go
func sumOfDigits(n int) int {
    // Базовый случай: если число однозначное
    if n < 10 {
        return n
    }

    // Рекурсивный случай:
    // n%10 - получаем последнюю цифру (остаток от деления на 10)
    // n/10 - отбрасываем последнюю цифру (целочисленное деление)
    // sumOfDigits(n/10) - рекурсивно обрабатываем оставшееся число
    return n%10 + sumOfDigits(n/10)
}

// Разберем sumOfDigits(12345) по шагам:
//
// 1. sumOfDigits(12345)
//    12345 < 10? Нет → 12345%10 = 5 + sumOfDigits(12345/10=1234)
//
// 2. sumOfDigits(1234)
//    1234 < 10? Нет → 1234%10 = 4 + sumOfDigits(1234/10=123)
//
// 3. sumOfDigits(123)
//    123 < 10? Нет → 123%10 = 3 + sumOfDigits(123/10=12)
//
// 4. sumOfDigits(12)
//    12 < 10? Нет → 12%10 = 2 + sumOfDigits(12/10=1)
//
// 5. sumOfDigits(1)
//    1 < 10? Да → возвращаем 1 (базовый случай!)
//
// Теперь раскрутка:
// 5. возвращает 1
// 4. возвращает 2 + 1 = 3
// 3. возвращает 3 + 3 = 6
// 2. возвращает 4 + 6 = 10
// 1. возвращает 5 + 10 = 15 ✓
```

## Ключевые выводы:

1. **Рекурсия в Go создает новый stack frame для каждого вызова**
2. **Максимальная глубина ограничена размером стека** (по умолчанию ~1MB)
3. **Go не оптимизирует хвостовую рекурсию** в отличие от функциональных языков
4. **Всегда определяйте базовый случай первым** для избежания бесконечной рекурсии
5. **Для глубокой рекурсии используйте итеративные алгоритмы или мемоизацию**
6. **Рекурсия отлично подходит для обхода древовидных структур**, но плоха для линейных вычислений с большой глубиной

Для практики рекомендую реализовать:

1. Обход бинарного дерева поиска
2. Алгоритм Ханойской башни
3. Генератор всех перестановок (permutations)
4. Поиск в глубину (DFS) для графов

Каждый из этих примеров покажет разные аспекты рекурсии и поможет лучше понять, когда и как её применять в реальных проектах на Go.
