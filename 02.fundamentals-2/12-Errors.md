## **Часть 1: Введение в ошибки в Go**

**Текст автора:**

> Errors are a fundamental part of any programming language. Allowing programs to handle exceptional conditions gracefully. In go! Errors are represented by the error interface, which is a built in type used to indicate the presence of an error condition.

**Подробное объяснение:**

### **Что такое ошибка в Go?**

В Go ошибки — это **не исключения (exceptions)**, как в многих других языках. Это **обычные значения**, которые функции возвращают наряду с полезным результатом.

### **Интерфейс `error`**

```go
type error interface {
    Error() string
}
```

**Что здесь происходит под капотом:**

1. **`type error interface`** — `error` объявлен как интерфейс в **встроенном пакете (builtin package)**.
2. **`Error() string`** — любой тип, который имеет метод `Error()` возвращающий `string`, автоматически удовлетворяет интерфейсу `error`.
3. **Встроенный пакет** — это специальный пакет Go, который автоматически импортируется во все программы. Его типы и функции доступны без явного импорта.

### **Почему это важно?**

Этот дизайн означает, что ошибки в Go — это **первоклассные значения (first-class citizens)**:

- Их можно присваивать переменным
- Передавать как аргументы
- Возвращать из функций
- Сравнивать (в том числе с `nil`)

---

## **Часть 2: Простой пример создания ошибки**

**Код автора:**

```go
func squareRoot(x float64) (float64, error) {
    if x < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    return 1, nil
}
```

### **Построчный разбор:**

**1. Сигнатура функции:**

```go
func squareRoot(x float64) (float64, error)
```

- `squareRoot` — имя функции
- `(x float64)` — один параметр типа `float64`
- `(float64, error)` — возвращает два значения: `float64` (результат) и `error` (ошибка)

**Под капотом:** В Go функции могут возвращать несколько значений. Компилятор преобразует это в структуру с несколькими полями или использует регистры процессора для эффективной передачи.

**2. Проверка условия:**

```go
if x < 0 {
```

- Стандартная проверка. Если `x` меньше 0, квадратный корень из отрицательного числа в вещественных числах не существует.

**3. Создание ошибки:**

```go
return 0, errors.New("math: square root of negative number")
```

**Что такое `errors.New()` под капотом?**

В исходном коде Go (пакет `errors`):

```go
// errors/errors.go
func New(text string) error {
    return &errorString{text}
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

**Разберем детально:**

1. **`errors.New("текст")`** вызывает функцию `New` из пакета `errors`.
2. **`&errorString{text}`** создает указатель на структуру `errorString` с полем `s`, содержащим наш текст.
3. **Структура `errorString`** имеет метод `Error() string`, поэтому она удовлетворяет интерфейсу `error`.

**Почему используется указатель (`&`)?**

- Экономия памяти: копируется только указатель (8 байт на 64-битной системе), а не вся строка.
- Гарантирует, что сравнение ошибок с `==` работает корректно (сравниваются адреса в памяти).

**4. Возврат без ошибки:**

```go
return 1, nil
```

- **`nil`** — это нулевое значение для интерфейсов (включая `error`).
- Под капотом интерфейс в Go — это структура из двух указателей:
  - Указатель на информацию о типе (type information)
  - Указатель на значение (value pointer)
- Когда интерфейс равен `nil`, оба указателя равны нулю.

---

## **Часть 3: Обработка ошибок**

**Код автора:**

```go
result, err := squareRoot(16)
if err != nil {
    fmt.Println(err)
    return
}
fmt.Println(result)
```

### **Подробный разбор:**

**1. Вызов функции и получение ошибки:**

```go
result, err := squareRoot(16)
```

- **Краткое объявление (:=)** создает две новые переменные: `result` и `err`.
- Переменной `err` присваивается второе возвращаемое значение функции.

**2. Проверка ошибки:**

```go
if err != nil {
```

- **`err != nil`** — проверяет, не является ли ошибка `nil`.
- Если `err` содержит `nil` — ошибки нет.
- Если `err` не `nil` — произошла ошибка.

**Почему именно такая проверка?**
Это **идиома Go (Go idiom)**. Почти все функции, которые могут завершиться с ошибкой, возвращают ошибку последним значением.

**3. Обработка ошибки:**

```go
fmt.Println(err)
return
```

- `fmt.Println(err)` вызывает метод `Error()` неявно. `fmt` пакеты знают об интерфейсе `error` и вызывают его метод для получения строки.
- `return` — выход из функции. В `main` это завершает программу.

---

## **Часть 4: Альтернативный стиль проверки ошибок**

**Код автора:**

```go
if err := process(data); err != nil {
    fmt.Println("Error:", err)
    return
}
```

### **Что здесь происходит под капотом?**

**1. Объявление переменной в условии if:**

```go
if err := process(data); err != nil {
```

**Разберем синтаксис:**

- Часть до `;` — **инициализирующее выражение (init statement)**
- Часть после `;` — **условие (condition)**

**Это эквивалентно:**

```go
err := process(data)
if err != nil {
    fmt.Println("Error:", err)
    return
}
```

**2. Зачем это нужно?**

- **Ограничение области видимости:** переменная `err` существует только внутри блока `if`.
- **Более чистый код:** объявление и проверка в одной строке.
- **Предотвращает случайное повторное использование:** нельзя использовать `err` после блока `if`.

**Под капотом компилятора:**
Компилятор Go создает отдельную область видимости для переменной `err`, которая существует только в рамках этого блока `if`.

---

## **Часть 5: Пользовательские типы ошибок**

**Код автора:**

```go
type myError struct {
    message string
}

func (m *myError) Error() string {
    return fmt.Sprintf("Error: %s", m.message)
}

func process() error {
    return &myError{message: "custom error message"}
}
```

### **Глубокий разбор:**

**1. Объявление структуры:**

```go
type myError struct {
    message string
}
```

- Создаем новый тип `myError` — простую структуру с одним полем.

**2. Реализация интерфейса `error`:**

```go
func (m *myError) Error() string {
    return fmt.Sprintf("Error: %s", m.message)
}
```

**Что значит `(m *myError)`?**

- **`*myError`** — это **получатель метода (method receiver)** типа "указатель на `myError`".
- **Почему указатель?** Две основные причины:
  - **Изменяемость:** если метод должен изменять структуру
  - **Эффективность:** избегаем копирования всей структуры при вызове метода

**Под капотом методов:**
Когда Go видит вызов `err.Error()`, где `err` имеет тип `*myError`, он:

1. Проверяет, что тип `*myError` имеет метод `Error() string`
2. Неявно передает указатель на структуру как первый аргумент (получатель)

**3. Возврат пользовательской ошибки:**

```go
func process() error {
    return &myError{message: "custom error message"}
}
```

**Магия интерфейсов:**

- `&myError{...}` создает указатель на структуру `myError`
- Этот указатель **неявно преобразуется** в тип `error`, потому что `*myError` реализует интерфейс `error`
- Под капотом создается **интерфейсное значение (interface value)**, содержащее:
  - Указатель на информацию о типе `*myError`
  - Указатель на конкретную структуру `myError`

---

## **Часть 6: Интерфейс `error` в builtin пакете**

**Текст автора показывает исходный код Go:**

```go
// Built-in package
type error interface {
    Error() string
}
```

### **Что такое builtin пакет?**

**Под капотом:**

1. **`builtin`** — это **виртуальный пакет**, который существует только в документации и исходном коде компилятора.
2. **Его содержимое доступно всегда** — не требует импорта.
3. **Содержит фундаментальные элементы языка:**
   - Базовые типы (`int`, `string`, `bool`, etc.)
   - Функции (`len`, `cap`, `make`, `new`, `panic`, `recover`)
   - Константы (`true`, `false`, `nil`)
   - Интерфейсы (`error`)

**Почему `error` в builtin, а не в отдельном пакете?**

- `error` используется **повсеместно**
- Помещение в `builtin` устраняет необходимость импорта
- Подчеркивает фундаментальную роль ошибок в языке

---

## **Часть 7: Обертывание ошибок (Error Wrapping)**

**Код автора:**

```go
func readConfig() error {
    return errors.New("config error")
}

func readData() error {
    err := readConfig()
    if err != nil {
        return fmt.Errorf("read data: %w", err)
    }
    return nil
}
```

### **Что такое `%w` и как это работает?**

**1. Функция `fmt.Errorf`:**

```go
return fmt.Errorf("read data: %w", err)
```

**Под капотом `fmt.Errorf`:**
Когда используется `%w`, `fmt.Errorf` создает специальную структуру, которая реализует интерфейсы:

- `error` — через метод `Error()`
- `wrapper` — неэкспортируемый интерфейс с методом `Unwrap() error`

**2. Структура обернутой ошибки:**
В исходном коде Go (упрощенно):

```go
type wrapError struct {
    msg string
    err error  // сохраняет исходную ошибку
}

func (e *wrapError) Error() string {
    return e.msg
}

func (e *wrapError) Unwrap() error {
    return e.err
}
```

**3. Цепочка ошибок (Error Chain):**

```
read data: config error
    ↑ wrapper        ↑ wrapped error
```

**4. Извлечение обернутых ошибок:**
Можно использовать функции из пакета `errors`:

```go
// Проверка, содержится ли конкретная ошибка в цепочке
if errors.Is(err, configError) { ... }

// Получение конкретного типа из цепочки
var configErr *ConfigError
if errors.As(err, &configErr) { ... }

// Разворачивание цепочки
originalErr := errors.Unwrap(err)
```

---

## **Часть 8: Важные концепции и рекомендации**

### **1. `panic` vs `error`**

**`panic`** — для **непоправимых ситуаций**:

- Нехватка памяти
- Невозможность продолжить выполнение (например, не найден обязательный файл конфигурации)
- Ошибки программиста (assertion failures)

**`error`** — для **ожидаемых проблем**:

- Файл не найден
- Сетевое соединение разорвано
- Неверный ввод пользователя

### **2. Принципы хороших ошибок:**

**Плохо:**

```go
return errors.New("error")
```

**Хорошо:**

```go
return fmt.Errorf("userService.GetUser(%d): %w", userID, err)
```

**Что должно быть в хорошей ошибке:**

- Контекст: какая операция выполнялась
- Параметры: с какими данными работали
- Исходная ошибка: что пошло не так на нижнем уровне

### **3. Производительность**

**Под капотом создание ошибки:**

1. **`errors.New`** — очень дешевая операция (аллокация одной маленькой структуры)
2. **`fmt.Errorf`** — дороже (форматирование строки, возможные аллокации)
3. **Создание стектрейса** — в Go по умолчанию ошибки не содержат стектрейс (в отличие от исключений в других языках)

**Почему нет стектрейса по умолчанию?**

- **Производительность:** создание стектрейса дорого
- **Философия Go:** явная передача контекста через обертывание ошибок
- При необходимости можно использовать пакеты вроде `github.com/pkg/errors`

---

## **Часть 9: Как ошибки работают в runtime**

### **Представление интерфейса в памяти**

**Структура интерфейса (упрощенно):**

```go
type iface struct {
    tab  *itab          // информация о типе и методах
    data unsafe.Pointer // указатель на конкретное значение
}
```

**Для `error`:**

- `tab` указывает на информацию, что это тип, реализующий `Error() string`
- `data` указывает на конкретную структуру ошибки

### **Сравнение ошибок**

**Когда `err == nil`?**
Только когда оба поля (`tab` и `data`) равны `nil`.

**Важная ловушка:**

```go
var err error
fmt.Println(err == nil) // true

var err *MyError        // nil указатель на MyError
var err2 error = err    // интерфейс НЕ равен nil!
fmt.Println(err2 == nil) // false!
```

**Почему?**

- `err` — `nil` указатель на `MyError`
- `err2` — интерфейсное значение с `tab` указывающим на тип `*MyError` и `data = nil`
- Интерфейс с `tab != nil` и `data = nil` **не равен** `nil`

---

## **Часть 10: Лучшие практики из реальных проектов**

### **1. Создание типизированных ошибок**

```go
// Определяем типы ошибок как константы
const (
    ErrUserNotFound = errors.New("user not found")
    ErrInvalidInput = errors.New("invalid input")
)

// Или как структуры с дополнительной информацией
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on %s: %s", e.Field, e.Message)
}
```

### **2. Проверка типов ошибок**

```go
// Старый способ (до Go 1.13)
if err, ok := err.(*ValidationError); ok {
    // Обработка ValidationError
}

// Новый способ (Go 1.13+)
var valErr *ValidationError
if errors.As(err, &valErr) {
    // Обработка ValidationError
}
```

### **3. Логирование ошибок**

```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
    err := processRequest(r)
    if err != nil {
        // Логируем с контекстом
        log.Printf("handleRequest: failed to process %s %s: %v",
            r.Method, r.URL.Path, err)

        // Пользователю - минимальная информация
        http.Error(w, "Internal server error", http.StatusInternalServerError)
    }
}
```

---

## **Заключение**

**Ключевые выводы:**

1. **Ошибки в Go — это значения**, а не исключения
2. **Интерфейс `error`** минималистичен: всего один метод
3. **Идиоматичная проверка**: `if err != nil`
4. **Обертывание ошибок** (`%w`) создает цепочки ошибок с сохранением контекста
5. **Производительность**: ошибки в Go дешевы, потому что не содержат стектрейс по умолчанию
6. **nil интерфейс != nil указатель**: важное различие при работе с интерфейсами

**Философия Go в отношении ошибок:**

- **Явность лучше неявности**: вы видите каждую проверку ошибки
- **Простота**: базовый интерфейс из одного метода
- **Производительность**: минимальные накладные расходы
- **Контроль**: разработчик решает, как обрабатывать каждую ошибку

Этот подход требует большего количества кода для проверки ошибок, но дает полный контроль над потоком выполнения и делает поведение программы предсказуемым и отлаживаемым.
