## **1. Что такое хеширование?**

Хеширование — это процесс преобразования данных в строку фиксированной длины (хеш) с помощью специального алгоритма (хеш-функции).

---

## **2. Характеристики хеширования:**

1. **Фиксированный размер вывода:** Независимо от размера входных данных, хеш всегда имеет одинаковую длину.

   - SHA-256: 256 бит = 32 байта
   - SHA-512: 512 бит = 64 байта

2. **Детерминированность:** Одинаковые входные данные всегда дают одинаковый хеш.

3. **Уникальность (эффект лавины):** Малейшее изменение во входных данных полностью меняет хеш.
   Например:

   - "course" и "courze" (разница в одной букве) дадут совершенно разные хеши.

4. **Необратимость:** Невозможно восстановить исходные данные из хеша.

5. **Эффективность:** Хеш-функции работают быстро даже на слабых компьютерах.

---

## **3. Зачем нужно хеширование?**

1. **Хранение паролей:** Пароли хранятся в виде хешей, а не в открытом виде.
2. **Целостность данных:** Проверка файлов на изменение (как при скачивании Go-установщика).
3. **Быстрый поиск:** Используется в хеш-таблицах для быстрого доступа к данным.

---

## **4. Пример 1: Простое хеширование без соли**

**Код:**

```go
package main

import (
    "crypto/sha256"
    "crypto/sha512"
    "fmt"
)

func main() {
    password := "password123"

    // SHA-256
    hash256 := sha256.Sum256([]byte(password))
    fmt.Println("Password:", password)
    fmt.Println("SHA256 hash:", hash256)
    fmt.Printf("SHA256 hex: %x\n", hash256)

    // SHA-512
    hash512 := sha512.Sum512([]byte(password))
    fmt.Println("SHA512 hash:", hash512)
    fmt.Printf("SHA512 hex: %x\n", hash512)
}
```

**Вывод в консоли:**

```
Password: password123
SHA256 hash: [239 146 183 120 ... байтовый массив ...]
SHA256 hex: ef92b778... (64 шестнадцатеричных символа)
SHA512 hash: [207 131 225 53 ... байтовый массив ...]
SHA512 hex: cf83e1357e... (128 шестнадцатеричных символов)
```

**Что происходит:**

- `sha256.Sum256([]byte(password))` преобразует строку в байтовый срез и вычисляет SHA-256 хеш.
- `%x` в `Printf` преобразует байтовый массив в шестнадцатеричную строку.
- SHA-512 хеш длиннее (64 байта = 128 hex-символов).

---

## **5. Что такое "соль" (salt) и зачем она нужна?**

**Проблема:** Если два пользователя имеют одинаковый пароль, их хеши будут одинаковыми. Это позволяет атакерам использовать "радужные таблицы".

**Решение:** Добавляем уникальную случайную строку (соль) к паролю перед хешированием.

**Пример:**

- Пользователь 1: пароль "123" + соль "abc" → хеш1
- Пользователь 2: пароль "123" + соль "xyz" → хеш2
- Хеши разные, хотя пароли одинаковые!

---

## **6. Пример 2: Хеширование с солью и проверка пароля**

**Полный код с объяснением:**

```go
package main

import (
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "fmt"
    "io"
)

// Генерация соли (16 криптографически безопасных случайных байтов)
func generateSalt() ([]byte, error) {
    salt := make([]byte, 16)
    _, err := io.ReadFull(rand.Reader, salt)
    if err != nil {
        return nil, err
    }
    return salt, nil
}

// Хеширование пароля с солью
func hashPassword(password string, salt []byte) string {
    // Объединяем соль и пароль
    saltedPassword := append(salt, []byte(password)...)
    // Вычисляем хеш
    hash := sha256.Sum256(saltedPassword)
    // Возвращаем хеш в виде base64 строки
    return base64.StdEncoding.EncodeToString(hash[:])
}

func main() {
    // === ЭТАП РЕГИСТРАЦИИ (пользователь создаёт аккаунт) ===

    // Пароль, который ввёл пользователь при регистрации
    signUpPassword := "password123"

    // Генерируем соль
    salt, err := generateSalt()
    if err != nil {
        fmt.Println("Error generating salt:", err)
        return
    }

    // Хешируем пароль с солью
    signUpHash := hashPassword(signUpPassword, salt)

    // Кодируем соль в base64 для хранения в БД
    saltStr := base64.StdEncoding.EncodeToString(salt)

    // В БД сохраняем: saltStr и signUpHash

    fmt.Println("Соль (в БД):", saltStr)
    fmt.Println("Хеш пароля (в БД):", signUpHash)

    // === ЭТАП ВХОДА (пользователь логинится) ===

    // Пароль, который ввёл пользователь при входе
    loginPassword := "password123"

    // Извлекаем соль из БД и декодируем
    decodedSalt, err := base64.StdEncoding.DecodeString(saltStr)
    if err != nil {
        fmt.Println("Error decoding salt:", err)
        return
    }

    // Хешируем введённый пароль с той же солью
    loginHash := hashPassword(loginPassword, decodedSalt)

    // Сравниваем хеши
    if signUpHash == loginHash {
        fmt.Println("✓ Пароль верный! Пользователь вошёл в систему.")
    } else {
        fmt.Println("✗ Неверный пароль. Вход отклонён.")
    }

    // Покажем разницу с хешем без соли
    hashNoSalt := sha256.Sum256([]byte(signUpPassword))
    fmt.Printf("Хеш БЕЗ соли: %x\n", hashNoSalt)
    fmt.Println("Хеш С солью:", signUpHash)
}
```

**Вывод в консоли:**

```
Соль (в БД): QWxhZGRpbjpvcGVuIHNlc2FtZQ==
Хеш пароля (в БД): 7Jq3eCwJyVk1vL8YgT9Z8A==
✓ Пароль верный! Пользователь вошёл в систему.
Хеш БЕЗ соли: ef92b778...
Хеш С солью: 7Jq3eCwJyVk1vL8YgT9Z8A==
```

**Что происходит по шагам:**

### **Регистрация:**

1. Пользователь вводит пароль "password123"
2. Генерируется случайная соль (16 байт)
3. Соль и пароль объединяются: `[соль] + "password123"`
4. Вычисляется SHA-256 хеш от объединённых данных
5. Соль кодируется в base64 и сохраняется в БД
6. Хеш пароля сохраняется в БД

### **Вход:**

1. Пользователь вводит пароль
2. Из БД извлекается закодированная соль
3. Соль декодируется из base64
4. Пароль хешируется с той же солью
5. Полученный хеш сравнивается с хешем из БД

---

## **7. Как работает `io.ReadFull(rand.Reader, salt)`?**

```go
salt := make([]byte, 16)  // Создаём буфер на 16 байтов
_, err := io.ReadFull(rand.Reader, salt)
```

- `rand.Reader` из пакета `crypto/rand` генерирует криптографически безопасные случайные числа
- `io.ReadFull` читает из `rand.Reader` до тех пор, пока не заполнит весь буфер `salt` (16 байтов)
- Возвращает количество прочитанных байтов (игнорируем с помощью `_`) и ошибку

---

## **8. Криптографически безопасные vs обычные случайные числа**

| Характеристика            | `crypto/rand`              | `math/rand`                   |
| ------------------------- | -------------------------- | ----------------------------- |
| Безопасность              | Криптографически безопасен | Не безопасен для криптографии |
| Предсказуемость           | Непредсказуем              | Предсказуем (если знать seed) |
| Использование             | Ключи, токены, соли        | Игры, симуляции               |
| Seed (начальное значение) | Не требуется (берёт из ОС) | Требуется задать              |

**Пример генерации соли с `math/rand` (НЕ ДЕЛАЙТЕ ТАК для паролей!):**

```go
import "math/rand"

// НЕБЕЗОПАСНО для паролей!
salt := make([]byte, 16)
rand.Read(salt)  // Использует math/rand, а не crypto/rand
```

---

## **9. Почему кодируем соль в base64 перед сохранением в БД?**

1. **Безопасность:** Атакер не знает, что это base64-кодированная соль
2. **Универсальность:** Base64 — стандартный текстовый формат
3. **Альтернативы:** Можно использовать base32, base16 или собственную кодировку

**Пример разных кодировок для одной соли:**

```go
salt := []byte{0x01, 0x02, 0x03, 0x04}

base64 := base64.StdEncoding.EncodeToString(salt)  // "AQIDBA=="
hex := fmt.Sprintf("%x", salt)                     // "01020304"
base32 := base32.StdEncoding.EncodeToString(salt)  // "AEBAQA=="
```

---

## **10. Что происходит при взломе БД?**

1. Атакер видит:
   - `saltStr = "QWxhZGRpbjpvcGVuIHNlc2FtZQ=="`
   - `signUpHash = "7Jq3eCwJyVk1vL8YgT9Z8A=="`
2. Не знает, что это base64
3. Даже если догадается — не знает алгоритм хеширования (SHA-256)
4. Даже если узнает алгоритм — не может восстановить пароль из хеша

---

## **11. Проверка с неверным паролем**

**Код:**

```go
// Пользователь вводит неверный пароль
loginPassword := "wrongpassword"
loginHash := hashPassword(loginPassword, decodedSalt)

if signUpHash == loginHash {
    fmt.Println("Вход успешен")
} else {
    fmt.Println("✗ Неверный пароль. Вход отклонён.")
}
```

**Вывод:**

```
✗ Неверный пароль. Вход отклонён.
```

---

## **12. Сравнение хешей с солью и без**

**Код:**

```go
// Хеш только пароля (без соли)
hashNoSalt := sha256.Sum256([]byte("password123"))
fmt.Printf("Хеш БЕЗ соли: %x\n", hashNoSalt)

// Хеш пароля с солью
hashWithSalt := hashPassword("password123", salt)
fmt.Println("Хеш С солью:", hashWithSalt)
```

**Вывод:**

```
Хеш БЕЗ соли: ef92b778... (одинаков для всех с паролем "password123")
Хеш С солью: 7Jq3eCwJ... (уникален для каждого пользователя)
```

---

## **13. Итог:**

1. **Всегда используйте хеширование для паролей**
2. **Всегда добавляйте случайную соль** к каждому паролю
3. **Используйте криптографически безопасные функции** (`crypto/rand`, `crypto/sha256`)
4. **Храните соль отдельно** от хеша (в той же БД, но в другом поле)
5. **Используйте стандартные алгоритмы** (SHA-256, SHA-512)
6. **Не изобретайте свои алгоритмы** шифрования/хеширования
