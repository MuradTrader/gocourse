### 1. **Сущность срезов**

- **Динамические представления массивов**: Срезы не хранят данные самостоятельно, а являются "окнами" (views) в базовые массивы. Это ссылочный тип.
- **Гибкость vs массивы**: В отличие от массивов с фиксированной длиной, срезы могут динамически расти/уменьшаться, что делает их удобнее для большинства задач.
- **Пример**:
  ```go
  var numbers []int  // Объявление среза без фиксации длины
  numbers1 := []int{1, 2, 3}  // Инициализация с значениями (без var)
  ```

---

### 2. **Связь с базовыми массивами**

- **Ссылочная модель**: Срез содержит указатель на базовый массив, длину (len) и ёмкость (cap).
- **Ёмкость (capacity)**:  
  `cap(slice)` возвращает количество элементов _в базовом массиве_ от первого элемента среза до конца массива.  
  Пример:
  ```go
  arr := [5]int{1, 2, 3, 4, 5}
  slice1 := arr[1:4]  // [2,3,4], len=3, cap=4 (элементы 1-4 в массиве)
  ```

---

### 3. **Создание срезов**

- **Через `make`**:
  ```go
  slice := make([]int, 5)    // len=5, cap=5
  slice := make([]int, 3, 5) // len=3, cap=5 (3 элемента + 2 свободных)
  ```
- **Из массива**:
  ```go
  arr := [5]int{1,2,3,4,5}
  slice1 := arr[1:4]  // элементы с индекса 1 до 3 (4 не включается!)
  ```
  - **Важно**: Синтаксис `[start:end]` включает `start`, но исключает `end` (как в математике [start, end)).

---

### 4. **Операции с элементами**

- **Добавление (`append`)**:
  ```go
  slice1 = append(slice1, 6, 7)  // Добавляет 6 и 7 в конец
  ```
  - Если ёмкости недостаточно, `append` создаёт новый базовый массив (обычно с удвоенной cap).
- **Копирование (`copy`)**:
  ```go
  sliceCopy := make([]int, len(slice1))
  copy(sliceCopy, slice1)  // Копирует элементы из source в destination
  ```
- **Изменение элемента**:
  ```go
  slice1[3] = 50  // Изменяет элемент по индексу (как в массивах)
  ```

---

### 5. **Особые состояния срезов**

- **Nil-срез**:
  ```go
  var nilSlice []int  // Не ссылается на массив, len=0, cap=0
  ```
  - Используется для обозначения "отсутствия среза" (аналог `null`).

---

### 6. **Итерация и многомерные структуры**

- **Итерация**:
  ```go
  for i, v := range slice1 {
    fmt.Println(i, v)  // i - индекс, v - значение
  }
  ```
- **2D-срезы** (вариативная длина):
  ```go
  var twoD [][]int
  for i := 0; i < 3; i++ {
      innerLen := i + 1
      twoD = append(twoD, make([]int, innerLen))  // Вложенный срез
      for j := 0; j < innerLen; j++ {
          twoD[i][j] = i + j  // Значение = сумма индексов
      }
  }
  // Результат: [[0], [1,2], [2,3,4]]
  ```

---

### 7. **Работа с под-срезами (slice operator)**

- **Синтаксис `[low:high]`**:
  ```go
  slice2 := slice1[2:4]  // Элементы с индексами 2 и 3 (4 не включается!)
  ```
  - Пример: Для `slice1 = [2,3,4,6,7]` результат `slice2 = [4,6]`.
- **Ёмкость под-среза**:
  ```go
  slice1 := []int{2,3,4,6,7}  // len=5, cap=5
  slice2 := slice1[2:4]        // len=2, cap=3 (базовый массив от индекса 2 до конца)
  ```

---

### 8. **Практические аспекты**

- **Сравнение срезов**:
  ```go
  import "slices"
  if slices.Equal(slice1, sliceCopy) {
      fmt.Println("Срезы равны")
  }
  ```
- **Почему срезы > массивов**:
  - Динамический размер (не нужно знать длину заранее).
  - Передача в функции без копирования (работают как ссылки).
  - Широко используются в стандартной библиотеке (обработка строк, JSON, сети).

---

### 9. **Производительность и нюансы (добавлено в контексте)**

- **Общая память**: Если два среза созданы из одного массива, изменение одного повлияет на другой.
  ```go
  arr := [3]int{1,2,3}
  a := arr[:2]  // [1,2]
  b := arr[1:]  // [2,3]
  a[1] = 99     // b[0] тоже станет 99!
  ```
- **Эффективность `append`**: При добавлении элементов:
  - Если `len < cap`, данные пишутся в существующий массив.
  - Если `len == cap`, создаётся новый массив (обычно cap × 2), что требует времени O(n).

---

### 10. **Заключение**

- **Ключевые преимущества**:
  - Гибкость: Изменение размера через `append`.
  - Удобство: Встроенные функции (`len`, `cap`, `copy`, `append`).
  - Эффективность: Работают как ссылки, минимизируя копирование данных.
- **Где используются**: Строки (строки — это срезы байт), JSON-данные, базы данных, многопоточные операции. Автор прав: в реальных проектах срезы встречаются в 90% случаев вместо массивов.

Разберу пример построения двумерного среза (2D slice) с переменной длиной вложенных срезов **до атомов**, как вы просили. Каждый шаг будет объяснен с анализом состояния памяти.

### Исходный код:

```go
var twoD [][]int
for i := 0; i < 3; i++ {
    innerLen := i + 1
    twoD = append(twoD, make([]int, innerLen))
    for j := 0; j < innerLen; j++ {
        twoD[i][j] = i + j
    }
}
// Результат: [[0], [1,2], [2,3,4]]
```

---

### Пошаговый разбор "до атомов":

**Шаг 0: Инициализация**

- `var twoD [][]int`  
  → Создается срез `twoD` типа "срез срезов int".  
  → Начальное состояние: `nil` (длина 0, емкость 0, нет базового массива).  
  → **Визуализация памяти:**
  ```
  twoD: nil
  ```

**Шаг 1: Итерация i=0**

1. `innerLen := 0 + 1` → `innerLen = 1`
2. `twoD = append(twoD, make([]int, 1))`  
   → `make([]int, 1)` создает срез `[0]` (базовый массив `[1]int{0}`).  
   → `append` добавляет этот срез в `twoD`.  
   → **Новое состояние:**
   ```
   twoD: [
      [0]   // Срез #0 (длина=1, емкость=1)
   ]
   ```
3. Вложенный цикл `j=0 to 0`:  
   → `twoD[0][0] = 0 + 0` → `0`  
   → **Итог:** `twoD[0] = [0]`

---

**Шаг 2: Итерация i=1**

1. `innerLen := 1 + 1` → `innerLen = 2`
2. `twoD = append(twoD, make([]int, 2))`  
   → `make([]int, 2)` создает срез `[0, 0]` (базовый массив `[2]int{0, 0}`).  
   → `append` добавляет его в `twoD`.  
   → **Новое состояние:**
   ```
   twoD: [
      [0],  // Срез #0
      [0,0] // Срез #1 (длина=2, емкость=2)
   ]
   ```
3. Вложенный цикл `j=0 to 1`:
   - `j=0`: `twoD[1][0] = 1 + 0` → `1`
   - `j=1`: `twoD[1][1] = 1 + 1` → `2`  
     → **Итог:** `twoD[1] = [1, 2]`

---

**Шаг 3: Итерация i=2**

1. `innerLen := 2 + 1` → `innerLen = 3`
2. `twoD = append(twoD, make([]int, 3))`  
   → `make([]int, 3)` создает срез `[0,0,0]` (базовый массив `[3]int{0,0,0}`).  
   → `append` добавляет его в `twoD`.  
   → **Новое состояние:**
   ```
   twoD: [
      [0],       // Срез #0
      [1,2],     // Срез #1
      [0,0,0]    // Срез #2 (длина=3, емкость=3)
   ]
   ```
3. Вложенный цикл `j=0 to 2`:
   - `j=0`: `twoD[2][0] = 2 + 0` → `2`
   - `j=1`: `twoD[2][1] = 2 + 1` → `3`
   - `j=2`: `twoD[2][2] = 2 + 2` → `4`  
     → **Итог:** `twoD[2] = [2, 3, 4]`

---

### Финальное состояние памяти:

```go
twoD = [][]int{
    {0},       // Срез #0 (базовый массив = [1]int{0})
    {1, 2},    // Срез #1 (базовый массив = [2]int{1,2})
    {2, 3, 4}, // Срез #2 (базовый массив = [3]int{2,3,4})
}
```

---

### Ключевые концепции "под микроскопом":

1. **Динамическая структура**:  
   Каждый вложенный срез — самостоятельный объект в памяти. Они **не связаны** между собой (в отличие от "вырезок" из одного массива).

2. **Работа `append`**:  
   При каждом вызове `append` для `twoD`:

   - Если ёмкости недостаточно, выделяется новый базовый массив (обычно 2× от текущей ёмкости).
   - В нашем случае:
     - После `i=0`: `cap(twoD)=1`
     - После `i=1`: `cap(twoD)=2` (удвоение)
     - После `i=2`: `cap(twoD)=4` (снова удвоение)

3. **Работа `make`**:

   ```go
   make([]int, innerLen)
   ```

   → Создает срез с:

   - `len = innerLen`
   - `cap = innerLen`
   - Все элементы инициализированы `0`.

4. **Вычисление значений**:  
   Формула `i + j` отражает **глобальные индексы** в структуре:
   - `i` = индекс строки (внешний срез)
   - `j` = индекс столбца (внутренний срез)

---

### Визуализация памяти в конце:

```
Адрес 0x1000: twoD (header) = [ptr, len=3, cap=4]
│
├─→ Адрес 0x2000: [header среза #0] → [ptr, len=1, cap=1] → Данные: [0] (по адресу 0x3000)
├─→ Адрес 0x2010: [header среза #1] → [ptr, len=2, cap=2] → Данные: [1,2] (по адресу 0x4000)
└─→ Адрес 0x2020: [header среза #2] → [ptr, len=3, cap=3] → Данные: [2,3,4] (по адресу 0x5000)
```

Каждый вложенный срез имеет собственный заголовок (pointer, len, cap) и свой базовый массив.

---

### Почему это важно?

- **Гибкость**: Можно создавать "неровные" структуры данных (как в примере: `[[1 элемент], [2 элемента], [3 элемента]]`).
- **Производительность**: `append` и `make` оптимизированы, но при работе с большими данными нужно учитывать переаллокации.
- **Безопасность**: Изменение элемента `twoD[1][0]` не затронет другие срезы, так как у каждого свой базовый массив.

### Подробный разбор примера с двумерным срезом

**Исходный код:**

```go
twoD := make([][]int, 3)
for i := 0; i < 3; i++ {
    innerLen := i + 1
    twoD[i] = make([]int, innerLen)
    for j := 0; j < innerLen; j++ {
        twoD[i][j] = i + j
    }
}
```

### Шаг 1: Инициализация внешнего среза

```go

twoD := make([][]int, 3)

```

- `make` - встроенная функция Go для создания срезов, карт и каналов.

- `[][]int` - тип: срез срезов целых чисел. Это означает, что `twoD` будет срезом, каждый элемент которого - срез целых чисел.

- `3` - длина внешнего среза. Таким образом, мы создаем срез, который будет содержать 3 элемента (каждый элемент - срез `[]int`).

- На этом этапе внешний срез `twoD` инициализирован, но каждый его элемент (каждый внутренний срез) имеет нулевое значение для типа `[]int`, то есть `nil`. Мы должны инициализировать каждый внутренний срез отдельно.

### Шаг 2: Цикл по внешнему срезу

```go

for i := 0; i < 3; i++ {

```

- Цикл выполняется для индексов `i` от 0 до 2 (включительно), так как условие `i < 3`.

### Шаг 3: Определение длины внутреннего среза

```go

innerLen := i + 1

```

- Для каждого индекса `i` внешнего среза мы определяем длину внутреннего среза как `i + 1`.

- При `i=0` -> `innerLen=1`

- При `i=1` -> `innerLen=2`

- При `i=2` -> `innerLen=3`

### Шаг 4: Инициализация внутреннего среза

```go

twoD[i] = make([]int, innerLen)

```

- Создаем внутренний срез типа `[]int` длиной `innerLen`.

- `make([]int, innerLen)` создает срез целых чисел длиной `innerLen`. При этом:

- Срез инициализируется нулевыми значениями типа `int` (то есть все элементы будут `0`).

- Емкость (capacity) среза будет равна длине, если не указана явно.

### Шаг 5: Вложенный цикл для заполнения внутреннего среза

```go

for j := 0; j < innerLen; j++ {

twoD[i][j] = i + j

}

```

- Внутренний цикл выполняется для каждого индекса `j` от 0 до `innerLen-1`.

- Значение элемента `twoD[i][j]` устанавливается равным `i + j`.

### Пошаговое выполнение

**Итерация 1: i = 0**

- `innerLen = 0 + 1 = 1`

- Создаем внутренний срез: `twoD[0] = make([]int, 1)` -> `[0]`

- Внутренний цикл: `j` от 0 до 0 (т.к. `innerLen=1`, условие `j < 1`).

- `j=0`: `twoD[0][0] = 0 + 0 = 0`

- Результат: `twoD[0] = [0]`

**Итерация 2: i = 1**

- `innerLen = 1 + 1 = 2`

- Создаем внутренний срез: `twoD[1] = make([]int, 2)` -> `[0, 0]`

- Внутренний цикл: `j` от 0 до 1.

- `j=0`: `twoD[1][0] = 1 + 0 = 1`

- `j=1`: `twoD[1][1] = 1 + 1 = 2`

- Результат: `twoD[1] = [1, 2]`

**Итерация 3: i = 2**

- `innerLen = 2 + 1 = 3`

- Создаем внутренний срез: `twoD[2] = make([]int, 3)` -> `[0, 0, 0]`

- Внутренний цикл: `j` от 0 до 2.

- `j=0`: `twoD[2][0] = 2 + 0 = 2`

- `j=1`: `twoD[2][1] = 2 + 1 = 3`

- `j=2`: `twoD[2][2] = 2 + 2 = 4`

- Результат: `twoD[2] = [2, 3, 4]`

### Итоговое значение `twoD`

После выполнения всего кода, `twoD` будет содержать:

```go

[][]int{

[]int{0},

[]int{1, 2},

[]int{2, 3, 4},

}

```

Или в более компактной записи:

```go

[][]int{

{0},

{1, 2},

{2, 3, 4},

}

```

### Визуализация

```

twoD (внешний срез) = [

[0]           -> индекс 0

[1, 2]        -> индекс 1

[2, 3, 4]     -> индекс 2

]

```

### Ключевые моменты

1. **Динамическая структура**: Каждый внутренний срез имеет свою длину, которая определяется во время выполнения.

2. **Инициализация вложенных структур**: Внешний срез инициализируется с заданной длиной, но каждый его элемент (внутренний срез) должен быть инициализирован отдельно.

3. **Нулевые значения**: При создании среза с помощью `make([]int, length)`, все элементы инициализируются нулевым значением типа (`0` для `int`).

4. **Индексация**: Обратите внимание, что индексация начинается с `0`. Вложенные циклы используют индексы `i` и `j` для доступа к элементам.

### Дополнительное объяснение от автора курса

Автор курса подчеркивает, что такой способ создания двумерных структур (срезов срезов) позволяет создавать "зубчатые" структуры (jagged arrays), где каждый внутренний срез может иметь разную длину. Это отличается от многомерных массивов (которые в Go имеют фиксированные размеры на всех уровнях).

Также автор добавляет, что для отладки сложных вложенных циклов можно использовать `fmt.Printf` для вывода значений индексов и элементов в процессе заполнения, как он это сделал в своем примере с сообщениями "adding value ...".

Этот пример демонстрирует гибкость срезов в Go и их применимость для построения сложных структур данных.

Мы уже разбирали срезы, но теперь углубимся в их внутреннее устройство и сравнение с массивами.

В Go срезы (slices) и массивы (arrays) — это принципиально разные типы данных.

### 1. Массивы (Arrays)

- **Фиксированная длина**: Длина массива — часть его типа. Например, `[3]int` и `[5]int` — разные типы.

- **Значение (value type)**: При присваивании массива другой переменной или передаче в функцию создается **копия** всего массива.

- **Размер**: Определяется на этапе компиляции и не может быть изменен.

Пример:

```go

var arr1 [3]int = [3]int{1, 2, 3}  // массив из 3 элементов

arr2 := arr1  // arr2 — это полная копия arr1. Изменения в arr2 не затронут arr1.

```

### 2. Срезы (Slices)

- **Динамическая длина**: Срез не имеет фиксированной длины. Он является "окном" в базовый массив.

- **Ссылочный тип (под капотом)**: Срез — это структура данных, содержащая:

- Указатель (pointer) на базовый массив.

- Длину (length) — текущее количество элементов в срезе.

- Емкость (capacity) — общее количество элементов в базовом массиве, начиная с первого элемента среза.

Определение типа среза (примерно так он выглядит в исходниках Go, но не доступно в пользовательском коде):

```go

type slice struct {

array *[underlying_array_length]elementType

len   int

cap   int

}

```

### 3. Создание среза

- **Из массива**:

```go

arr := [5]int{1,2,3,4,5}

sl := arr[1:4]  // sl = [2,3,4], len=3, cap=4 (потому что в базовом массиве после первого элемента есть еще 4 элемента: индексы 1,2,3,4)

```

Теперь `sl` ссылается на базовый массив `arr`, начиная с индекса 1.

- **Литерал среза**:

```go

sl := []int{1,2,3}  // создается массив [3]int{1,2,3} и срез, который на него указывает (len=3, cap=3)

```

- **С помощью `make`**:

```go

sl := make([]int, 3, 5)  // создает срез, указывающий на новый массив [5]int{0,0,0,0,0}, но срез видит только первые 3 элемента: [0,0,0] (len=3, cap=5)

```

### 4. Внутреннее устройство среза (под капотом)

- **Базовый массив**: Все срезы построены поверх массивов. Когда создается срез (кроме nil-среза), выделяется память под массив.

- **Заголовок среза (slice header)**: Это структура (указатель, len, cap), которая описывает срез. При передаче среза в функцию копируется заголовок, но не базовый массив. Поэтому изменения элементов среза в функции будут видны снаружи (так как указатель на массив одинаковый). Но если внутри функции изменяют сам срез (например, делают append и перезаписывают срез), то это не влияет на внешний срез, если не вернуть его и не переприсвоить.

### 5. Операции над срезами и их последствия

- **Append**:

```go

sl = append(sl, 6)

```

- Если в базовом массиве есть место (cap > len), то элемент добавляется в свободное место, len увеличивается на 1.

- Если места нет (cap == len), то:

1. Создается новый базовый массив (обычно удвоенной емкости, но для маленьких срезов алгоритм роста может быть иным).

2. Все элементы копируются в новый массив.

3. Добавляется новый элемент.

4. Возвращается срез, который ссылается на новый массив (и имеет новую len и cap).

Важно: после копирования в новый массив старый массив остается в памяти, но если на него больше нет ссылок, то он будет удален сборщиком мусора.

- **Срезы (slicing)**:

```go

newSlice := sl[1:3]

```

- `newSlice` будет использовать тот же базовый массив, что и `sl`.

- Указатель в `newSlice` будет на `sl[1]`.

- len = 2 (3-1), cap = (исходная cap sl - 1) — потому что отсчитываем от нового начала до конца исходного массива.

Пример:

```go

sl := []int{1,2,3,4,5}  // len=5, cap=5

sl2 := sl[1:3]           // [2,3], len=2, cap=4 (потому что в базовом массиве после элемента 1 осталось 4 элемента: 2,3,4,5)

```

**Осторожно**: Изменение элемента в `sl2` повлияет на `sl` (и наоборот), так как базовый массив один.

### 6. Nil-срез vs Пустой срез

- **Nil-срез**:

```go

var sl []int  // sl == nil

```

- Указатель = nil, len = 0, cap = 0.

- Используется, когда нужно обозначить отсутствие среза (например, как ошибка).

- **Пустой срез**:

```go

sl := []int{}  // или make([]int, 0)

```

- Указатель не nil (указывает на специальный нулевой массив в памяти), len=0, cap=0.

- Полезен, когда нужно возвращать пустую коллекцию (например, при JSON-сериализации nil-срез может стать null, а пустой срез — []).

### 7. Отличия срезов от массивов

| Характеристика | Массив | Срез |

|-------------------------|---------------------------------|-------------------------------------|

| **Тип** | Значение (value) | Ссылочный (header с указателем) |

| **Длина** | Фиксирована (часть типа) | Динамическая (может меняться) |

| **Передача в функцию** | Копируется весь массив | Копируется заголовок (массив не копируется) |

| **Инициализация** | `arr := [3]int{1,2,3}` | `sl := []int{1,2,3}` |

| **Изменение размера** | Невозможно | `append` может создать новый срез |

| **Сравнение** | `==` доступно для массивов | `==` не доступно (кроме сравнения с nil) |

### 8. Важные нюансы для собеседования

1. **Когда append может изменить базовый массив?**

Если после среза (slicing) исходного среза, к нему добавляют элементы и при этом в базовом массиве есть место, то добавление происходит в тот же массив, и это может затронуть другие срезы, которые с ним связаны.

Пример:

```go

a := []int{1,2,3,4}

b := a[0:2]  // [1,2], cap=4 (есть место)

b = append(b, 5)  // [1,2,5] — но это перезапишет a[2]!

// Теперь a: [1,2,5,4], b: [1,2,5]

```

2. **Как избежать неожиданностей?**

- Если вы не хотите, чтобы два среза делили один массив, используйте `copy`:

```go

newSlice := make([]int, len(oldSlice))

copy(newSlice, oldSlice)

```

- Или используйте полное сечение с указанием емкости (full slice expression) `a[low:high:max]`, которая ограничивает емкость нового среза до `max-low`:

```go

b := a[0:2:2]  // len=2, cap=2 — теперь append к b создаст новый массив и не испортит a.

```

3. **Производительность append**

- Алгоритм роста емкости: обычно удваивает текущую cap, если она меньше 1024, а затем увеличивает на 25%. Это уменьшает количество копирований (амортизированное время O(1)).

- Если вы знаете итоговый размер среза, выделите память сразу:

```go

sl := make([]int, 0, 1000)  // избегаем переаллокаций при 1000 append

```

4. **Срезы и многопоточность**

- Заголовок среза (header) не является потокобезопасным. Если несколько горутин изменяют один и тот же срез (особенно через append), это приведет к состоянию гонки. Используйте мьютексы или каналы для синхронизации.

5. **Отображение в памяти (memory layout)**

- Элементы среза хранятся в непрерывном участке памяти. Это важно для производительности (кэш процессора) и для передачи в низкоуровневые функции (например, через `unsafe`).

### 9. Примеры для закрепления

**Пример 1: Как работает append?**

```go

a := []int{1,2,3}

b := append(a, 4)  // т.к. cap(a) = 3, то не хватает места -> создается новый массив [1,2,3,4] и возвращается срез на него.

// a остался [1,2,3] (cap=3), b = [1,2,3,4] (cap=6? - обычно 6, так как 3*2)

```

**Пример 2: Общий базовый массив**

```go

a := []int{1,2,3,4}

b := a[1:3]        // b = [2,3] (cap=3)

b[0] = 10          // a[1] становится 10 -> a = [1,10,3,4]

```

**Пример 3: Ограничение емкости**

```go

a := []int{1,2,3,4}

b := a[1:3:3]      // b = [2,3] (cap=2) — емкость ограничена до 2

b = append(b, 5)   // так как cap=2 и len=2, то создается новый массив для b. Теперь b = [2,3,5], а a = [1,2,3,4]

```

### 10. Заключение

Понимание внутреннего устройства срезов — ключ к эффективному и безопасному использованию Go. Помните:

- Срезы — это заголовки, указывающие на массивы.

- Append может создавать новые массивы, если не хватает емкости.

- Несколько срезов могут делить один массив, что может привести к неочевидным изменениям.

### Подробное внутреннее устройство срезов (slices) в Go

#### Структура среза под капотом

Срез — это **дескриптор**, состоящий из 3 компонентов (в реализации Go):

```go
type sliceHeader struct {
    Data unsafe.Pointer // Указатель на базовый массив
    Len  int            // Текущее количество элементов
    Cap  int            // Максимальное количество элементов без переаллокации
}
```

Размер заголовка среза: **24 байта** (64-битная система).

#### Как это работает в памяти:

1. **Базовый массив**:

   - Реальный массив, хранящий данные
   - Создается явно или неявно (через литерал, `make()`, `new()`)
   - Располагается в куче (heap)

2. **Заголовок среза**:
   - Легковесная структура (24 байта)
   - Копируется при передаче в функции
   - Содержит ссылку на базовый массив

Пример создания:

```go
s := make([]int, 3, 5)
```

```
Память:
┌───────────┐       ┌──────────────┐
│ Заголовок │──────▶│ Базовый массив│
├─────┬─────┤       ├──┬──┬──┬──┬──┤
│ Len:3    │       │0 │0 │0 │? │? │
│ Cap:5    │       └──┴──┴──┴──┴──┘
└─────┴─────┘         ↑
Data-указатель───────┘
```

### Ключевые операции и их внутренняя работа

#### 1. Создание среза

**Варианты:**

```go
// Через make
s1 := make([]int, 3, 5)  // Явное указание len/cap

// Из массива
arr := [5]int{1,2,3,4,5}
s2 := arr[1:4]           // Len=3, Cap=4 (элементы 2,3,4)

// Литерал
s3 := []int{1,2,3}       // Len=Cap=3
```

**Под капотом:**

- Для `make()`:
  ```c
  // Псевдокод runtime
  void* arr = runtime.malloc(5 * sizeof(int))
  sliceHeader{Data: arr, Len: 3, Cap: 5}
  ```

#### 2. Append (добавление элементов)

**Механика:**

```go
s := []int{1,2,3}
s = append(s, 4)
```

1. Проверка: `if Len+1 <= Cap`
2. Если места хватает:
   - Добавление элемента в существующий массив
   - Увеличение Len в заголовке
3. Если места НЕ хватает:
   - Аллокация нового массива (обычно Cap × 2, если Cap < 1024, иначе +25%)
   - Копирование всех элементов
   - Добавление нового элемента
   - Обновление указателя в заголовке

**Критично:**

- После переаллокации срез указывает на НОВЫЙ массив
- Старый массив остается до сборки мусора

#### 3. Срезы (slicing)

```go
arr := [5]int{1,2,3,4,5}
s1 := arr[1:4]  // [2,3,4] (Len=3, Cap=4)
s2 := s1[1:3]   // [3,4]   (Len=2, Cap=3)
```

**Память:**

```
Базовый массив: [1,2,3,4,5]
s1: Data → &arr[1], Len=3, Cap=4
s2: Data → &arr[2], Len=2, Cap=3
```

#### 4. Копирование (copy)

```go
src := []int{1,2,3}
dst := make([]int, 2)
copy(dst, src)  // dst = [1,2]
```

**Особенности:**

- Копирует min(len(src), len(dst)) элементов
- Не изменяет Cap получателя
- Работает за O(n)

### Отличия срезов от массивов

#### 1. Типы данных

```go
var arr [3]int // Тип "array of 3 int"
var sl []int   // Тип "slice of int"
```

#### 2. Размерность

| Свойство             | Массив              | Срез                  |
| -------------------- | ------------------- | --------------------- |
| Фиксированный размер | Да (часть типа)     | Нет (динамический)    |
| Изменение размера    | Невозможно          | Append/copy           |
| Передача в функцию   | По значению (копия) | По ссылке (заголовок) |

#### 3. Инициализация

```go
// Массив
arr1 := [3]int{1,2,3}   // Явный размер
arr2 := [...]int{1,2,3}  // Вывод размера

// Срез
sl1 := []int{1,2,3}      // Без размера
sl2 := make([]int, 3, 5) // С указанием len/cap
```

#### 4. Сравнение

```go
arr1 := [3]int{1,2,3}
arr2 := [3]int{1,2,3}
fmt.Println(arr1 == arr2) // true (сравнение значений)

sl1 := []int{1,2,3}
sl2 := []int{1,2,3}
fmt.Println(sl1 == sl2) // Ошибка! (не сравнимы)
```

#### 5. Нулевое значение

```go
var arr [3]int  // [0,0,0]
var sl []int    // nil (Len=0, Cap=0)
```

### Критические нюансы для собеседования

#### 1. Изменение через срезы

```go
arr := [3]int{1,2,3}
s1 := arr[:]   // Срез всего массива
s1[0] = 99     // arr[0] тоже становится 99!

s2 := append(s1, 4) // Создает новый массив
s2[0] = 100         // arr[0] не изменится
```

#### 2. Утечки памяти

```go
func getBigSlice() []byte {
    data := make([]byte, 0, 1<<30) // 1GB
    return data[:10]               // Возвращаем 10 байт
}
// Заголовок среза сохраняет ссылку на 1GB массив!
```

**Решение:**

```go
return append([]byte{}, data[:10]...)
```

#### 3. Производительность append

- Амортизированная сложность O(1)
- Стратегия роста:
  - Cap < 1024: ×2
  - Cap ≥ 1024: ×1.25
- Среднее количество копий: O(1) на операцию

#### 4. Трехиндексные срезы

```go
arr := [5]int{1,2,3,4,5}
s := arr[1:3:3] // Len=2, Cap=2
```

- Предотвращает неожиданные изменения базового массива
- Полезно для контроля Cap

### Визуализация работы срезов

```
Этап 1: Создание
arr := [5]int{1,2,3,4,5}
s := arr[1:4]

Память:
arr: [1,2,3,4,5]
s: {Data:&arr[1], Len=3, Cap=4}

Этап 2: Append без переаллокации
s = append(s, 6)
→ arr[4]=6 → arr: [1,2,3,4,6]
→ s: {Data:&arr[1], Len=4, Cap=4}

Этап 3: Append с переаллокацией
s = append(s, 7)
→ Новый массив [2,3,4,6,7] (Cap=8)
→ s: {Data:&newArr[0], Len=5, Cap=8}
→ Старый arr больше не изменяется!
```

### Сводная таблица отличий

| Характеристика         | Массив               | Срез                    |
| ---------------------- | -------------------- | ----------------------- |
| **Размер**             | Фиксированный        | Динамический            |
| **Передача в функцию** | Копирование данных   | Копирование заголовка   |
| **Сравнение**          | По значению          | Только с nil            |
| **Нулевое значение**   | Zero-filled          | nil (Len=0, Cap=0)      |
| **Базовое хранилище**  | Явный массив         | Ссылка на массив в куче |
| **Изменение размера**  | Невозможно           | Append/копирование      |
| **Производительность** | Быстрее (стек)       | Гибче (куча)            |
| **Использование**      | Фиксированные данные | 90% случаев в Go        |

### Примеры для собеседования

**Вопрос:** Что выведет код?

```go
a := []int{1,2,3}
b := a
b = append(b, 4)
fmt.Println(a[0], b[3])
```

**Ответ:**

1. `a[0] = 1` (не изменился)
2. `b[3] = 4` (новая аллокация при append)

---

**Вопрос:** Как избежать утечки памяти при возврате части большого среза?
**Ответ:** Явное копирование:

```go
func safeReturn() []int {
    big := make([]int, 0, 1000)
    // ... операции ...
    result := make([]int, len(big[:10]))
    copy(result, big[:10])
    return result
}
```
