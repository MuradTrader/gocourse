# **Лекция: Rate Limiting (Ограничение скорости)**

**Результат кода в консоли:** На данном этапе код не предоставлен, так как это теоретическая часть лекции. Практические примеры будут в следующей лекции.

## **Что такое Rate Limiting?**

Rate Limiting (ограничение скорости) - это техника, используемая для контроля объема входящего или исходящего трафика в систему или из нее. Она обеспечивает, чтобы ресурсы не были перегружены, а использование оставалось в пределах предопределенных лимитов.

**Где используется:**

- Веб-серверы
- API (интерфейсы прикладного программирования)
- Приложения

**Цели использования:**

- Предотвращение злоупотреблений
- Управление нагрузкой
- Обеспечение справедливого использования

## **Rate Limiting в Go**

Важное замечание: Rate Limiting **не является встроенной функцией** языка Go. Это не встроенная функция или что-то подобное. Мы будем использовать множество вещей, которые мы изучили до сих пор, чтобы настроить механизм ограничения скорости.

**Почему это важно:** Я хочу, чтобы вы стали proficient (опытными) в:

- Мьютексах (mutexes)
- Атомарных счетчиках (atomic counters)
- Каналах (channels)
- Всех продвинутых функциях

Создание механизма ограничения скорости - хорошая идея для практики всех изученных концепций, особенно важных концепций, таких как мьютексы и атомарные счетчики.

## **Зачем использовать Rate Limiting?**

### **1. Предотвращение перегрузки (Prevent Overload)**

Защищает наши системы от перегрузки слишком большим количеством запросов или операций.

### **2. Реализация справедливости (Implements Fairness)**

Обеспечивает равномерное распределение ресурсов между пользователями или клиентами.

### **3. Предотвращение злоупотреблений (Preventing Abuse)**

Снижает риск злоупотребления или неправильного использования ресурсов.

### **4. Управление затратами (Cost Management)**

**Очень, очень важно.** Когда у вас есть собственный API, когда вы запускаете собственные приложения на сервере в облаке, вы хотите контролировать операционные расходы, управляя использованием ресурсов.

## **Алгоритмы Rate Limiting**

### **1. Token Bucket Algorithm (Алгоритм токенного ведра)**

- Использует ведро (bucket) для хранения токенов (tokens), которые представляют возможность выполнять операции
- Токены добавляются с фиксированной скоростью
- Операции могут выполняться только если токены доступны

**Ключевое свойство:** Позволяет всплески (bursts) трафика, поддерживая стабильную скорость с течением времени

### **2. Leaky Bucket Algorithm (Алгоритм протекающего ведра)**

- Похож на токенное ведро, но с фиксированной скоростью "протекания"
- Запросы добавляются в ведро, и ведро "протекает" с постоянной скоростью

**Ключевое свойство:** Сглаживает всплески трафика для обеспечения постоянной скорости вывода

### **3. Fixed Window Counter (Счетчик с фиксированным окном)**

- Считает запросы в пределах фиксированного временного окна (например, в минуту или любой другой продолжительности)
- Если счет превышает лимит, дальнейшие запросы отклоняются до сброса окна

**Ключевое свойство:** Прост в реализации, но может допускать всплески на границах окон

### **4. Sliding Window Log (Скользящее окно лога)**

- Ведет лог временных меток запросов
- Обеспечивает ограничения на основе количества запросов в скользящем временном окне

**Ключевое свойство:** Обеспечивает более точное ограничение скорости по сравнению с фиксированными окнами, но требует больше памяти

### **5. Sliding Window Counter (Счетчик со скользящим окном)**

- Комбинирует подходы фиксированного окна и скользящего окна
- Поддерживает счетчик для последних запросов и корректирует счет на основе скользящих временных окон

**Ключевое свойство:** Балансирует точность и использование памяти

## **Что будет в следующей лекции**

В следующей лекции мы начнем с **Token Bucket Algorithm (алгоритма токенного ведра)**. Мы создадим практический код для реализации этого алгоритма ограничения скорости.

**До встречи в следующей лекции!**
