Ниже приведён разбор текста очень подробно, по шагам и максимально простым языком. Если вы совсем не знакомы с тем, как работает компьютер (жёсткий диск, оперативная память, процессор и т. д.), я постараюсь объяснить всё на бытовых аналогиях.

---

## Вводная: зачем вообще понимать разницу между `go run` и `go build`

- **Что такое Go?**
  Go (или Golang) — это язык программирования и набор инструментов, которые позволяют написать программу (код) и превратить его в исполняемую программу (бинарник), которую можно запустить на компьютере.

- **Что делает команда `go run`?**
  Она «на лету» собирает (компилирует) ваш код и сразу же запускает его, **не оставляя после себя файла**, который можно было бы запускать снова и снова.

- **Что делает команда `go build`?**
  Она собирает (компилирует) ваш код и **сохраняет** результат в виде постоянной программы (файла-­приложения), которую можно запускать сколько угодно раз.

Если эти понятия (компиляция, бинарник, HDD/SSD, RAM) вам пока ничего не говорят — не переживайте. Дальше мы всё разложим «по полочкам».

---

## 1. Почему вообще спрашивают: «зачем `go run`, если есть `go build`?»

> **Автор говорит:**
> «Почему мы используем `go run`, когда можно просто сделать `go build`? Всё просто. `go build` создаёт «постоянную» программу (бинарник), тогда как `go run` создаёт «временную» программу и сразу же её запускает, но не оставляет на диске.»

### 1.1. Коротко о «постоянном» и «временном» бинарнике

1. **`go build` (постоянный бинарник)**

   - Когда вы запускаете `go build`, Go-утилита читает ваши файлы с расширением `.go` (исходники), преобразует их в машинный код (инструкции для процессора) и **записывает** получившийся файл (называемый «бинарником») рядом с вашими исходниками (обычно в ту же папку).
   - Этот файл остаётся на диске **пока вы его не удалите**. При следующем запуске такой программы повторно компиляция не нужна — вы просто запускаете уже готовую программу.

2. **`go run` (временный бинарник)**

   - Когда вы запускаете `go run`, Go-утилита тоже читает исходники, компилирует их в машинный код, но **не кладёт** результат в ту папку, где лежат ваши `.go`-файлы. Вместо этого Go быстро создаёт (временный) исполняемый файл где-то «на время» (например, в папке `/tmp` или даже может держать его «только в памяти»).
   - Как только скомпилированная программа завершила свою работу, Go сам удаляет этот временный файл. В папке с вашими `.go`-исходниками ничего не остаётся, кроме самих исходников.

#### Почему «persistent» (постоянный) и «temporary» (временный) важны?

- **Постоянный бинарник (`go build`)**:

  - Вы можете запускать его сколько угодно раз, не думая о пересборке.
  - Его можно копировать (например, на другой сервер или другу), хранить копии, подписывать цифровой подписью (для безопасности).
  - Это удобно, когда вы уже «доделали» программу и хотите, чтобы она жила как отдельный файл.

- **Временный бинарник (`go run`)**:

  - Удобен во время разработки, когда вы часто меняете код и сразу же хотите его проверить.
  - Не оставляет «мусора» в папке проекта: каждый раз — «сборка, запуск, удаление».
  - Если вы запускаете маленькую утилиту на раз-два, не нужно думать, куда положить файл-­программу — Go всё сам убирает сразу.

---

## 2. Подробно, что происходит при `go run`: «сборка + запуск» за один шаг

> **Автор говорит:**
> «`go run` компилирует и сразу запускает программу, не создавая постоянного файла. Go берёт ваши `.go`-файлы, с помощью компилятора создаёт временный бинарник (обычно где-то в `/tmp` или в оперативной памяти), запускает его, а после завершения программы удаляет этот временный файл.»

Разберём по шагам, что реально делает компьютер, когда вы в консоли пишете:

```bash
go run myprog.go
```

### 2.1. Шаг 1: Чтение исходных файлов (HDD/SSD → RAM)

1. **Исходник (.go)**

   - Допустим, у вас есть файл `myprog.go` на жёстком диске (HDD) или SSD. Это просто текстовый файл с кодом Go.
   - Когда вы запускаете `go run myprog.go`, операционная система (Windows, Linux, macOS) просит: «Открой файл `myprog.go`».
   - Компьютер читает этот файл **из хранилища** (HDD/SSD) и **загружает его содержимое в оперативную память (RAM)**, потому что дальше все операции — это работа с текстом и разбор кода, и это всё удобнее делать именно в RAM (там быстрее).

2. **Почему RAM?**

   - RAM (оперативная память) работает в разы быстрее, чем HDD или SSD. Поэтому весь «мозг» компилятора живёт в RAM: там он хранит промежуточные версии вашего кода, данные о функциях, переменных, «граф» зависимостей между кусочками кода и т. д.

### 2.2. Шаг 2: «Сборка» кода (лексинг, парсинг, оптимизации, генерация машинного кода)

После того как строки с кодом (`package main`, `func main() { ... }` и т. д.) оказались в RAM, Go-компилятор делает следующие этапы (они происходят «внутри» процесса `go` и тоже в оперативной памяти — никакой бинарник ещё не записан надолго на диск):

1. **Лексинг (лексер)**

   - Компилятор читает весь текст кода и разбивает его на части: ключевые слова (`package`, `func`, `import`), имена переменных, символы (`=`, `{`, `}`, `(`, `)`), числа, строки и т. д.
   - Эта разбивка на «лексемы» (токены) нужна, чтобы дальше понимать, что именно вы написали: «это ключевое слово», «это имя функции», «это число» и т. д.

2. **Парсинг (синтаксический анализ)**

   - Уже из «лексем» компилятор строит «дерево разбора» (AST, Abstract Syntax Tree).
   - Например, строка `fmt.Println("Hello")` становится в дереве примерно так:

     ```
     Вызов функции
       ├─ пакет: fmt
       ├─ имя функции: Println
       └─ аргументы
            └─ строковый литерал: "Hello"
     ```

   - На этом этапе компилятор понимает, какая структура у вашего кода, какие есть функции, какими именами они называются, какие параметры ожидают и т. д.

3. **Проверка типов (type checking)**

   - Go — это язык со строгой статической типизацией. Компилятор проверяет, что вы, например, не пытаетесь сложить строку и число, что в функцию переданы правильные аргументы и т. д.
   - Если вы в коде сделали опечатку или неверно использовали типы, компилятор остановится на этом этапе и выдаст ошибку, например:

     ```
     cannot use "abc" (untyped string) as type int in assignment
     ```

   - Пока есть ошибки, Go не перейдёт к следующим шагам.

4. **Преобразование в промежуточное представление (SSA) и оптимизации**

   - После того как компилятор «понял», что ваш код синтаксически и по типам правильный, он строит ещё более «низкоуровневое» представление внутреннего кода (SSA — Single Static Assignment).
   - На этом этапе компилятор может выполнять оптимизации: исправлять неэффективные конструкции, убирать мёртвый код (который никогда не будет выполняться), объединять одинаковые выражения и т. д.
   - Вся эта информация хранится **в оперативной памяти** (RAM), в виде набора структур и графов зависимостей.

5. **Генерация машинного кода (codegen)**

   - Теперь компилятор «переводит» оптимизированный код в реальные инструкции, которые поймёт процессор (CPU).
   - Например, для x86-64 (самая распространённая архитектура для ПК и серверов) эти инструкции — это последовательности байтов, говорящие CPU:

     ```
     MOV RAX, [адрес]
     ADD RAX, 5
     CALL fmt.Println
     RET
     ```

   - Эти инструкции образуют один «целостный» файл, который называется «исполняемым» (binary, бинарник).

6. **Линковка (linking)**

   - Go-программа не живёт «сама по себе». В неё входит рантайм Go (гонсчётчик горутин, сборщик мусора, базовые функции ввода-вывода и т. д.) и, возможно, сторонние библиотеки (если вы их подключали через `import`).
   - Линкер берёт ваш сгенерированный машинный код (объектный файл, обычно с расширением `.o`) и «склеивает» его со всеми нужными фрагментами рантайма и библиотек так, чтобы получился один самодостаточный файл, который можно запустить.
   - В итоге появляется уже полноценный исполняемый файл (ELF на Linux, PE на Windows, Mach-O на macOS).

➔ **Важно:** всё это (лексер, парсер, SSA, codegen, линковка) **происходит в RAM** и, возможно, с небольшими временными файлами в системной «временной» папке (например, `/tmp` на Linux). Пока компилятор не закончит линковку, «постоянного» бинарника в вашей папке проекта не появится.

### 2.3. Шаг 3: Создание временного исполняемого файла

- После того как компилятор и линкер собрали весь код, Go создаёт файл-­бинарник.
- На практике он кладёт этот бинарник куда-то в «временную рабочую область» (обычно в `/tmp` на Unix-подобных системах или во внутреннюю папку, заданную ОС).
- **Этот файл — полноценная исполняемая программа**, но Go заранее «знает», что этот файл нужен только «на время», чтобы сразу же запустить программу.

  - Часто говорят, что «бинарник хранится в RAM», но реально на диске (SSD/HDD) он может быть записан в папку `/tmp`. Иногда компилятор может «неписать» его на диск, а держать в RAM-­файловой системе (tmpfs), но с точки зрения пользователя важно: никак не сохраняется в папке вашего проекта.

### 2.4. Шаг 4: Запуск временного исполняемого файла (CPU + RAM)

1. **Создание процесса**

   - Go вызывает системный вызов вроде `execve` (Linux) или `CreateProcess` (Windows), чтобы ОС запустила сгенерированный временный файл как отдельный процесс.
   - В результате появляется новый процесс, которому ОС «делегирует» ресурсы:

     - **Куча (heap)** в RAM для динамических данных.
     - **Стек (stack)** в RAM для хранения локальных переменных и вызовов функций.
     - Блок памяти для кода (`.text`) и данных (`.data`, `.rodata`).

2. **CPU начинает исполнять инструкции**

   - Процессор (CPU) читает первые инструкции из секции `.text` временного бинарника, переводит их в транзисторные сигналы и выполняет.
   - Сначала идёт точка входа `_start` (низкоуровневая часть рантайма Go), она инициализирует рантайм, запускает планировщик горутин (Go-корутин), а потом вызывает вашу функцию `main.main()`.
   - Дальше ваши функции выполняются как обычно: могут печатать в консоль (`fmt.Println`), читать файлы, обращаться к сети — всё как написано в коде Go.

3. **Выполнение и завершение**

   - Пока ваша программа работает (пока `main` не завершил своё выполнение и не вышел из кода), процесс «живёт» в RAM (на самом деле часть данных может сбрасываться в своп, но об этом позже).
   - Когда `main` заканчивается или программа делает `os.Exit(0)`, процесс «умирает»: ОС освобождает все ресурсы (RAM, дескрипторы файлов, сокеты).

### 2.5. Шаг 5: Удаление временного исполняемого файла (чистка мусора)

- Сразу после того, как процесс завершился, Go-утилита (`go run`) понимает, что «цели достигнуты»: программа отработала.
- Она автоматически **удаляет** временный бинарник из той папки `/tmp` или из «виртуальной» файловой системы в RAM.
- Ваша папка проекта остаётся «чистой» — там только исходники и, возможно, какие-то сгенерированные вами файлы (но не сам бинарник).

➔ **Итого при `go run`:**

1. Вы ввели `go run myprog.go`.
2. Go-утилита:

   - Считала код из диска → загрузила в RAM.
   - С помощью компилятора → линковщика создала временный бинарник (в `/tmp` или «в RAM»).
   - Запустила этот бинарник.
   - Дождалась завершения работы.
   - Удалила бинарник.

3. В папке с исходниками ничего не осталось, кроме файлов `.go`.

---

## 3. Подробно, что происходит при `go build`: «сборка → запись → готовый файл»

> **Автор говорит:**
> «В отличие от `go run`, `go build` создаёт «постоянный» бинарник, который остаётся на диске, и которым вы можете пользоваться много раз.»

Тот же самый процесс компиляции + линковки, но с несколькими отличиями.

### 3.1. Шаг 1: Чтение исходников (HDD/SSD → RAM)

1. Go читает все `.go`-файлы вашего пакета (или конкретного файла `hello.go`, если вы явно указали).
2. Эти файлы загружаются в RAM.
3. Дальше всё то же самое: **лексинг**, **парсинг**, **проверка типов**, **оптимизации**, **генерация машинного кода**, **линковка** — всё это происходит «в RAM».

> **Важно:** на этом этапе компиляция в целом **не отличается** от `go run`: Go-компилятор точно так же строит AST, SSA, оптимизирует и т. д.

### 3.2. Шаг 2: Запись бинарника на диск (HDD/SSD)

Когда компилятор+линкер сформировали полноценный исполняемый файл (который умеет работать самостоятельно без участия `go`-утилиты), `go build` **записывает** этот файл туда, где вы сказали.

- Если вы просто запустили `go build hello.go` (или находясь в папке с `hello.go` набрали `go build`), Go положит результат в текущую папку:

  - Linux/macOS: файл с именем `hello` (без расширения).
  - Windows: файл `hello.exe`.

> **Замечание про флаг `-o`:**
> По умолчанию `go build` сам выберет имя файла (название папки или файла-­исходника). Но если вы хотите назвать бинарник по-своему, можно сделать:
>
> ```bash
> go build -o myapp_v1.2.3
> ```
>
> Тогда в папке появится именно файл `myapp_v1.2.3` (на Windows, если вы не указали `.exe`, Go сам добавит расширение).

### 3.3. Шаг 3: Запуск готового бинарника (очередной запуск без перекомпиляции)

1. **Как запустить?**

   - В Linux/macOS:

     ```bash
     ./hello
     ```

   - В Windows:

     ```powershell
     .\hello.exe
     ```

2. **Что делает ОС при запуске созданного файла?**

   1. Считывает заголовок ELF/PE/Mach-O с диска (то есть смотрит, какой формат у файла, куда «класть» код в память, где какие сегменты).
   2. Копирует сегцию с машинным кодом (`.text`) и данные (`.data`, `.rodata`) в RAM.
   3. Выделяет стек (RAM) для основного потока, настраивает регистры, указатель инструкций (Program Counter) указывает на точку входа (`_start`).
   4. ОС передаёт исполнение процессору (CPU), он начинает читать инструкции и выполнять их. Сначала рантайм Go инициализируется, потом вызывается ваша функция `main.main()`, и ваша программа «идёт».

3. **Что меняет по сравнению с `go run`?**

   - Нет шага «удалить файл» после окончания. Бинарник остаётся на диске и **может быть запущен снова** без пересборки.
   - Если вы изменили исходники, повторно запустить этот старый бинарник **не имеет смысла** — он будет работать как раньше, без ваших новых правок. Чтобы запустить изменения, нужно снова сделать `go build`.

### 3.4. Краткий итог по `go build`

- **Всё то же, что и при `go run`, через компиляцию и линковку.**
- **Отличие:** вместо временного бинари­ника вы получаете файл в вашей папке, он не удаляется автоматически.
- **Плюсы:**

  - Удобно, когда программа готова и вы хотите её «раскатать» (деплоить, передать кому-то).
  - Можно подсчитать контрольные суммы (SHA-1, MD5), проверить, что бинарник не изменился.
  - Можно положить файл в Docker-образ, создать .deb/.rpm-пакет (для Linux-дистрибутивов), установить его как сервис и т. д.

---

## 4. Когда использовать `go run`, а когда — `go build`

> **Автор говорит:**
> «Во время разработки, когда код постоянно меняется, лучше пользоваться `go run`, чтобы не удалять каждый раз старый бинарник. А когда вы готовы к деплою (релизу), используйте `go build`, чтобы получить «финальный» файл.»

### 4.1. Рекомендация № 1: Цикл разработки (`go run`)

1. **Частые правки и быстрый тест**

   - Представьте, что вы пишете код и каждую минуту исправляете одну строчку: добавили новый `fmt.Println`, поменяли условие, поправили функцию.
   - С `go run` достаточно каждый раз набрать:

     ```bash
     go run main.go
     ```

     Команда сама сделает «сборку» и «запуск» в одну операцию.

   - Вам **не нужно думать**: «А что, если остался старый бинарник? А куда я его положил? Не удалил ли я его?»

2. **Нет «мусора» в папке проекта**

   - Каждый раз вы получаете чистую папку: никакого файла `hello`, никакого `hello.exe`. У вас только `.go`-файлы и, может быть, другие ресурсы (картинки, конфиги).
   - Если бы вы постоянно делали `go build`, со временем в папке скопилось бы много разных версий бинарников, а вы могли бы случайно запустить не ту версию.

3. **Скорость**

   - Если проект очень маленький (один файл на пару десятков строчек), время компиляции минимально, и разница между `go run` и `go build && ./hello` почти неощутима.
   - Если проект крупный (много пакетов, зависимостей), каждый запуск `go run` (или `go build`) занимает ощутимое время. Но по-прежнему `go run`чище с точки зрения удобства.

### 4.2. Рекомендация № 2: Деплой и релиз (`go build`)

1. **Когда вы «окончательно» закончили работу над версией программы**

   - Например, у вас получился сервис версии 1.0. Вы хотите собрать бинарник для Linux x86_64 и положить его на сервер.
   - Вы делаете:

     ```bash
     go build -o myservice_v1.0
     ```

     В папке появится `myservice_v1.0`.

   - Вы можете проверить контрольную сумму команды:

     ```bash
     sha256sum myservice_v1.0
     ```

     и гарантировать, что этот файл точно такой, каким вы хотите его раздать.

2. **Дальнейшие преимущества**

   - **Повторный запуск**. Любой, у кого есть доступ к этому файлу, может запустить его без Go-установки (Go-рантайма) на машине, потому что бинарник уже «самодостаточный»: внутри него уже есть всё, что нужно.
   - **Копирование и перенос**. Можно передать файл на сервер, добавить в образ Docker, запаковать в архив, разместить на другом компьютере.
   - **Изоляция от исходников**. Если кто-то найдёт файл `myservice_v1.0` и запустит его, никак не сможет «сломать» исходники, потому что у него нет доступа к `.go`-файлам (это некий «чёрный ящик»).

3. **Использование в качестве утилиты**

   - Иногда вы хотите установить программу глобально на своём компьютере. Тогда есть команда `go install`. Она делает что-то вроде:

     ```bash
     go install ./...
     ```

     или

     ```bash
     go install github.com/user/project@latest
     ```

     — и результат (бинарник) кладётся в папку `$GOPATH/bin` (обычно `~/go/bin`).

   - После этого команда, например, `myservice` доступна в любой папке (если `$GOPATH/bin` есть в переменной среды PATH).

---

## 5. Что реально происходит «под капотом» с ресурсами компьютера

Часто, чтобы увидеть разницу между `go run` и `go build`, полезно представить, **какие ресурсы** (HDD/SSD, RAM, CPU) задействуются и **когда**.

### 5.1. Жёсткий диск (HDD/SSD)

1. **Исходники всегда лежат на диске**

   - Файлы `*.go`, `go.mod`, `go.sum` — это обычные файлы, постоянно хранящиеся в папке вашего проекта на HDD (жёстком диске) или на SSD (твердотельном накопителе).

2. **Что происходит при `go run` с диском**

   - Чтение исходников: Go читает файлы `.go` с диска.
   - **Временный бинарник**:

     - Чаще всего Go создаёт папку в системе, которая называется что-то вроде `/tmp/go-build12345/`. В ней появляются промежуточные файлы (файлы `.o`) и сам временный бинарник.
     - Эти файлы **записываются на диск** (или, если ваша система настроена, в RAM-диск, впечатление такое, что они хранятся в RAM).
     - Как только программа завершилась, Go удаляет папку `/tmp/go-build12345/` вместе с бинарником и промежуточными файлами.

   - Итог: после `go run` в вашей папке проекта **ничего не осталось**, а из системных временных файлов всё убрано.

3. **Что происходит при `go build` с диском**

   - Чтение исходников: точно так же.
   - Постоянный бинарник: вместо папки `/tmp` Go создаёт файл в **той папке, откуда вы вызвали `go build`** (или в том пути, что вы указали через `-o`).
   - После завершения в папке проекта остаётся новый файл, допустим, `hello` или `hello.exe`. Он находится на HDD/SSD «навсегда» (пока вы не удалите).

### 5.2. Оперативная память (RAM)

1. **Во время компиляции**

   - Почти всё, что касается «умных» операций (лексинг, парсинг, оптимизации, генерация машинного кода), происходит **в оперативной памяти**.
   - Компилятор строит AST (дерево), SSA (промежуточное представление), и для этого нужны большие объёмы RAM, особенно если проект крупный.

2. **Когда создаётся временный бинарник (`go run`)**

   - Часть компиляции держится в RAM, но в какой-то момент Go создаёт файлы в `/tmp`.
   - Когда бинарник запускается, ОС загружает сам исполняемый файл (содержимое секций `.text`, `.data`) в RAM.
   - Пока программа работает, весь её код и данные живут в RAM (в разных сегментах). Как только процесс завершается, операционная система «освобождает» эту память и удаляет временные файлы (если они были на диске).

3. **Когда создаётся постоянный бинарник (`go build`)**

   - Компиляция опять же сильно нагружает RAM.
   - Когда линкер собрал и записал файл на диск, ОС всё равно для ускорения может держать недавно использованные части этого файла в так называемом «кэше» файловой системы: фактически это часть RAM, где копируются буферы диска.
   - Но главное: бинарник лежит на диске, и каждый раз при запуске ОС будет загружать **лишь нужные для выполнения части** (обычно это секции с кодом и данными) в RAM.

### 5.3. Процессор (CPU)

1. **Компиляция**

   - Лексер и парсер — это не очень ресурсоёмкие этапы, но вот SSA-оптимизации и генерация машинного кода могут использовать несколько ядер CPU (Go-­компилятор умеет распараллеливать некоторые задачи).
   - Линковка большого проекта (множество пакетов) тоже немного «процессороёмкая», но не так сильно, как, например, компиляция C++-проекта. Go-компилятор спроектирован так, чтобы быть относительно быстрым.

2. **При `go run`**

   - CPU последовательно выполняет: чтение файлов → лексинг/парсинг → SSA → codegen → линковка → вызов нового процесса (execve) → исполнение вашей программы.
   - Когда ваш код начинает работать (в `main.main()`), CPU переключается на выполнение инструкций вашей программы (вычисления, чтение/запись, работа с сетью и т. д.). После завершения программа выдаёт результаты (в консоль, файл и т. д.), а процесс CPU возвращается к тому, что ему нужно делать дальше (к остальным задачам операционной системы или другим вашим программам).

3. **При `go build`**

   - То же самое, но на этапе «запись бинарника» CPU выполняет дополнительный простой шаг: взять готовый файл из RAM и записать его на диск (HDD/SSD).
   - После этого компиляция закончена, и CPU переключается на другие задачи. Бинарник с вашего взгляда «хранится» на диске, а CPU в дальнейшем может куда-то кэшировать части этого файла, если вы запустите его.

---

## 6. Итоги и простые рекомендации

### 6.1. Когда использовать `go run`

- **Вы только что написали кусочек кода** (например, пару строк) и хотите сразу проверить, что он делает, без лишних манипуляций с файлами.
- **Частая доработка**: вы правите что-то каждую минуту, и нужно как можно быстрее запустить и увидеть результат.
- **Не нужно думать** про имя бинарника, его удаление и т. д.: Go сам всё сделает «на время».
- **Вы не хотите «загрязнять» папку проекта** кучей разных версий бинарников.

### 6.2. Когда использовать `go build`

- **Вы закончили работу над версией программы** и хотите получить файл, который потом можно запустить без Go.
  Например, вы разрабатываете команду CLI, которую нужно раздать коллегам, или серверное приложение, которое отправляется на продакшн.
- **Вам нужно сохранить бинарник навсегда** (хотя бы до тех пор, пока вы сами не удалите).
  Например, вы делаете релиз: `go build -o myapp_v1.0`, проверяете контрольную сумму, можете залить бинарник на GitHub Release или куда-то ещё.
- **Установка утилиты на системном уровне**: `go install` автоматически скомпилирует и положит бинарник в `~/go/bin` (или `$GOPATH/bin`), добавит его в ваш PATH — и программу удобно запускать везде.

### 6.3. Сравнительная таблица «что, где, когда хранится»

| Действие           | Исходники (`.go`)        | Временный бинарник                        | Постоянный бинарник                                |
| ------------------ | ------------------------ | ----------------------------------------- | -------------------------------------------------- |
| `go run main.go`   | HDD/SSD → RAM (читаются) | `/tmp/.../main` (или RAM, но удаляется)   | отсутствует                                        |
| `go build main.go` | HDD/SSD → RAM (читаются) | промежуточные `.o` (RAM, пока компиляция) | `./main` (или `main.exe`) на HDD/SSD, **остаётся** |
| `go install`       | HDD/SSD → RAM (читаются) | промежуточные `.o` (RAM)                  | `~/go/bin/main` (HDD/SSD), **остаётся**            |

- **Исходники всегда «живут» на диске** (вы их написали и сохранили).
- **Временный бинарник при `go run` — «живет» только до тех пор, пока процесс не закончится, а затем удаляется**.
- **Постоянный бинарник при `go build` остается на диске, пока вы сами его не удалите**.

---

## 7. Заключение: ключевая идея «под капотом»

1. **Общий «конвейер» компиляции (и для `go run`, и для `go build`)**:

   1. Чтение `.go` из диска → загрузка в RAM.
   2. Лексинг → парсинг → проверка типов → оптимизации (SSA) → генерация машинного кода (все эти этапы в RAM).
   3. Линковка (склейка вашего кода с рантаймом и библиотеками) → итоговый исполняемый файл (временно в RAM или в `/tmp`).

2. **При `go run`**:

   - Итоговый бинарник **создаётся «где-то там» (RAM или временная папка)** и сразу же запускается.
   - По завершении работы бинарник **удаляется**, и в вашей папке с исходниками **никаких дополнительных файлов нет**.

3. **При `go build`**:

   - Итоговый бинарник **записывается в папку с проектом** (или туда, куда вы указали через `-o`).
   - Бинарник **остаётся** (пока вы сами его не удалите) и может запускаться без пересборки.

4. **Когда пользоваться чем**:

   - **`go run`**: удобнее во время быстрой разработки и тестов.
   - **`go build`**: используйте, когда готовы получить «финальный» файл для раздачи, деплоя, упаковки в контейнер и т. д.

---

### Ещё раз кратко простым языком:

- **Компьютер хранит файлы на диске (HDD/SSD).** Когда вы открываете файл, его содержимое попадает в оперативную память (RAM). Работа с RAM в сотни раз быстрее, чем с диском.

- **Процессор (CPU) — это «мозг», который выполняет машинные инструкции** (например, «скопировать 5 байт из A в B», «сложить два числа», «проверить условие»).

- **Go-компиляция («go run» и «go build») — это набор этапов, в ходе которых текстовый код превращается в серию машинных инструкций, пригодных для CPU.**

- При **`go run`**:

  1. Читаем код с диска → RAM.
  2. Компилируем → линкуем → получаем временный файл (обычно в `/tmp` или в RAM).
  3. Сразу запускаем (CPU начинает исполнять инструкции).
  4. Как только программа отработала, Go удаляет временный файл.

- При **`go build`**:

  1. Читаем код с диска → RAM.
  2. Компилируем → линкуем → получаем полноценный бинарник.
  3. **Записываем** этот бинарник **в папку проекта** (или куда вы указали).
  4. Бинарник остаётся, и вы можете запускать его без пересборки.

Надеюсь, теперь вы видите воочию, **как именно** и **где именно** создаются эти исполняемые файлы и **почему** разница между «временным» (`go run`) и «постоянным» (`go build`) бинарником так важна в разных этапах работы: от быстрого прототипирования до «финальной» сборки для деплоя.
