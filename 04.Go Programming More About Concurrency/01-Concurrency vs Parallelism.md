## Часть 1: Разница между конкурентностью и параллелизмом

### Определения:

1. **Конкурентность (Concurrency)** - способность системы обрабатывать несколько задач одновременно. Это управление несколькими задачами, которые выполняются в одно и то же время, но не обязательно исполняются в один и тот же момент.

2. **Параллелизм (Parallelism)** - одновременное выполнение нескольких задач, обычно с использованием нескольких процессоров или ядер для улучшения производительности.

## Пример 1: Конкурентное выполнение - печать чисел и букв

```go
package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 0; i < 5; i++ {
        fmt.Println(i)
        time.Sleep(500 * time.Millisecond)
    }
}

func printLetters() {
    letters := []string{"a", "b", "c", "d", "e"}
    for _, letter := range letters {
        fmt.Println(letter)
        time.Sleep(500 * time.Millisecond)
    }
}

func main() {
    go printNumbers()  // запускаем в отдельной горутине
    go printLetters()  // запускаем в другой горутине

    // Ждем 3 секунды, чтобы горутины успели завершиться
    time.Sleep(3 * time.Second)
}
```

**Результат выполнения (примерный вывод):**

```bash
0
a
1
b
2
c
3
d
4
e
```

**Добавим время для более точного анализа:**

```go
func printNumbers() {
    for i := 0; i < 5; i++ {
        fmt.Println(i, time.Now())
        time.Sleep(500 * time.Millisecond)
    }
}

func printLetters() {
    letters := []string{"a", "b", "c", "d", "e"}
    for _, letter := range letters {
        fmt.Println(letter, time.Now())
        time.Sleep(500 * time.Millisecond)
    }
}
```

**Результат выполнения с временем:**

```bash
0 2009-11-10 23:00:00.7168 +0000 UTC
a 2009-11-10 23:00:00.7168 +0000 UTC
1 2009-11-10 23:00:01.2180 +0000 UTC
b 2009-11-10 23:00:01.2180 +0000 UTC
2 2009-11-10 23:00:01.7189 +0000 UTC
c 2009-11-10 23:00:01.7189 +0000 UTC
3 2009-11-10 23:00:02.2180 +0000 UTC
d 2009-11-10 23:00:02.2180 +0000 UTC
4 2009-11-10 23:00:02.7189 +0000 UTC
e 2009-11-10 23:00:02.7189 +0000 UTC
```

**Объяснение:**

- Время на миллисекундном уровне одинаковое (7168)
- На микросекундном уровне есть небольшая разница
- Это показывает, что горутины работают почти параллельно
- Это пример параллельного выполнения

## Пример 2: Параллельная обработка с использованием WaitGroup и настройкой количества процессоров

```go
package main

import (
    "fmt"
    "sync"
    "time"
    "runtime"
)

// heavyTask симулирует тяжелую задачу
func heavyTask(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // Уменьшаем счетчик WaitGroup при завершении

    fmt.Printf("Task %d is starting\n", id)

    // Симулируем тяжелую операцию - пустой цикл
    for i := 0; i < 100_000_000; i++ {
        // Ничего не делаем, просто занимаем время
    }

    fmt.Printf("Task %d is finished\n", id)
}

func main() {
    // Устанавливаем максимальное количество используемых процессоров
    runtime.GOMAXPROCS(4)

    var wg sync.WaitGroup
    numThreads := 4

    // Запускаем тяжелые задачи
    for i := 0; i < numThreads; i++ {
        wg.Add(1)  // Увеличиваем счетчик WaitGroup
        go heavyTask(i, &wg)
    }

    // Ждем завершения всех задач
    wg.Wait()

    fmt.Println("All tasks completed at:", time.Now())
}
```

**Результат выполнения (примерный вывод):**

```bash
Task 0 is starting
Task 1 is starting
Task 2 is starting
Task 3 is starting
Task 1 is finished
Task 0 is finished
Task 2 is finished
Task 3 is finished
All tasks completed at: 2009-11-10 23:00:00.991 +0000 UTC
```

**Анализируем время завершения задач:**

```bash
Task 0 finished at: 2009-11-10 23:00:00.991899 +0000 UTC
Task 1 finished at: 2009-11-10 23:00:00.991912 +0000 UTC
Task 2 finished at: 2009-11-10 23:00:00.991928 +0000 UTC
Task 3 finished at: 2009-11-10 23:00:00.991935 +0000 UTC
```

**Объяснение:**

- Все задачи начинаются почти одновременно
- Завершаются с разницей в микросекундах
- Это показывает параллельное выполнение на разных ядрах процессора

**Увеличим количество потоков до 12:**

```go
func main() {
    runtime.GOMAXPROCS(12)  // Используем 12 ядер

    var wg sync.WaitGroup
    numThreads := 12

    for i := 0; i < numThreads; i++ {
        wg.Add(1)
        go heavyTask(i, &wg)
    }

    wg.Wait()
    fmt.Println("All tasks completed")
}
```

**Результат с 12 потоками:**

```bash
Task 0 is starting
Task 1 is starting
Task 2 is starting
Task 3 is starting
Task 4 is starting
Task 5 is starting
Task 6 is starting
Task 7 is starting
Task 8 is starting
Task 9 is starting
Task 10 is starting
Task 11 is starting
Task 0 is finished
Task 1 is finished
...
Task 11 is finished
All tasks completed
```

**Анализ времени:**

- Разница между первой и последней задачей: ~130 миллисекунд
- На микросекундном уровне: разница менее 4000 микросекунд (4 миллисекунд) между некоторыми задачами

## Ключевые различия между конкурентностью и параллелизмом:

### 1. Определение:

- **Конкурентность**: Управление несколькими задачами, не обязательно выполняющимися одновременно
- **Параллелизм**: Одновременное выполнение нескольких задач

### 2. Фокус:

- **Конкурентность**: Управление задачами и координация
- **Параллелизм**: Производительность через одновременное выполнение

### 3. Как работает:

- **Конкурентность**: Задачи могут чередоваться или планироваться
- **Параллелизм**: Задачи выполняются одновременно на разных ядрах процессора

### 4. Использование:

- **Конкурентность**: Для операций ввода-вывода, множественных соединений
- **Параллелизм**: Для вычислительно тяжелых задач или обработки больших данных

## Особые случаи:

### 1. Конкурентность без параллелизма:

**Пример**: Однопроцессорная система с разделением времени (time slicing)

- Один CPU с одним ядром
- Задачи делят время процессора
- CPU выделяет время разным задачам (например, 200 мс задаче A, 200 мс задаче B и т.д.)
- Это конкурентность, но не параллелизм

### 2. Чисто параллельные системы:

**Пример**: Независимые задачи, не требующие координации

- Полностью независимые задачи
- Могут выполняться параллельно без координации
- Пример: обработка разных изображений независимыми потоками

## Почему это важно для Go?

Go имеет встроенную поддержку конкурентности через горутины и каналы:

1. **Горутины**: Легковесные потоки, управляемые runtime Go
2. **Планировщик Go**: Может выполнять горутины параллельно, используя несколько ядер процессора

## Что дальше?

Следующие темы, которые автор упоминает:

1. **Состояния гонки (Race conditions)**: Проблемы при работе с общими ресурсами
2. **Взаимные блокировки (Deadlocks)**: Ситуации, когда задачи ждут друг друга и не могут продолжить выполнение

Эти проблемы возникают при работе с конкурентностью и параллелизмом, и Go предоставляет инструменты для их решения.

## Итоговая таблица различий:

| Аспект          | Конкурентность                  | Параллелизм                    |
| --------------- | ------------------------------- | ------------------------------ |
| **Определение** | Управление несколькими задачами | Одновременное выполнение       |
| **Цель**        | Организация и координация       | Увеличение производительности  |
| **Требования**  | Может работать на одном ядре    | Требует несколько ядер         |
| **Пример в Go** | Горутины, чередующие выполнение | Горутины на разных ядрах CPU   |
| **Сложности**   | Координация, коммуникация       | Синхронизация, race conditions |

**Вывод автора**: Понимание разницы между конкурентностью и параллелизмом критически важно для создания эффективного, масштабируемого ПО и эффективного использования аппаратных возможностей.
