Ниже я разложу каждую мысль автора на более глубокие уровни и объясню, что именно происходит «под капотом» в компьютере, когда вы используете команды `go run` и `go build`. По ходу буду ссылаться на ваши знания про HDD/SSD, RAM и работу процессора, чтобы понятно было, где и как хранится полученный исполняемый код, и почему это вообще важно.

---

## 1. Зачем спрашивать: «Почему `go run`, если есть `go build`?»

> **Автор:**
> «Now a question that comes up is why do we use `go run` when we can use `go build`?
> It’s a simple difference.
> With `go build` we are making an executable file, a persistent executable file.
> But when we use `go run` we are not making a persistent executable file.»

### 1.1. Суть различия

- **`go build`**: компилирует все ваши `.go`-файлы в одну программу и сохраняет результат на диске (HDD/SSD) в виде постоянного (persistent) бинарника.
- **`go run`**: компилирует ваш код «на лету», создаёт исполняемый файл, но не оставляет его на диске: временный бинарник хранится только в памяти (RAM) или в заранее выбранной «временной» папке, а после завершения работы программы этот исполняемый файл удаляется.

Поэтому, когда автор говорит «persistent executable file», он имеет в виду «диск-ориентированный бинарник, который останется у вас в папке после выполнения команды и которым можно пользоваться впоследствии». «Непостоянный» (temporary) означает, что этот файл не сохраняется навсегда — он просто создаётся, выполняется и сразу вычёркивается.

---

## 2. Что происходит при `go run`: компиляция и исполнение в один шаг

> **Автор:**
> «The `go run` command in Go is used to compile and execute a Go program in a single step, without explicitly creating a binary executable.
> Let’s break down what Go Run actually does when you execute `go run`.
> Go first compiles your Go source code, the `.go` files, into a temporary executable file in memory.
> So the executable file is being made, but it is not stored in our storage.
> The executable is stored in the RAM.
> Once the compilation is successful, Go immediately runs the compiled program.
> After the program execution completes, the temporary executable created by Go Run is discarded, leaving no persistent binary file on disk.»

### 2.1. Компиляция «в память» и временный файл

1. **Чтение исходников**

   - В вы выполнив `go run myprog.go`, утилита `go` начинает с того, что читает ваш файл `myprog.go` (или несколько файлов) с HDD/SSD через файловую систему. Эти байты текста загружаются в RAM, где будут происходить все последующие этапы: лексинг, парсинг, оптимизация и генерация машинного кода.

2. **Генерация машинного кода**

   - Go-компилятор (инструмент `gc`) выполняет весь обычный pipeline:

     - **Лексер** → **Парсер** → **Типовая проверка** → **SSA-оптимизации** → **Генерация машинного кода** (для вашей архитектуры, например x86_64).

   - На выходе компилятор создаёт объектный файл (обычно с расширением `.o`), а потом линкует его с библиотеками рантайма и стандартными пакетами, формируя исполняемый файл (ELF/PE/Mach-O) в бинарном формате — всё это происходит «внутри» временной рабочей директории в RAM.

3. **Временный исполняемый**

   - На практике Go-утилита создаёт временную директорию (часто в `/tmp/go-build<…>` или аналогичном месте) и туда записывает свой «промежуточный» бинарник. Этот бинарник физически хранится на диске (HDD/SSD) в папке `/tmp`, но с намерением, что он будет удалён сразу как только вы завершите работу.
   - Интересный момент: автор говорит «исполняемый файл хранится в RAM». В действительности часто используется гибрид: на этапе компиляции файлы могут писаться на диск, но так или иначе конечный бинарник держится в том же «временном» пространстве, и вам не нужно заботиться о его расположении «навсегда». При этом после выхода из процесса директива Go автоматически удаляет временные каталоги.

4. **Запуск полученного кода**

   - Как только линковка завершена успешно, Go сразу делает `exec` (или соответствующую команду ОС) и запускает этот временный бинарник в новом процессе.
   - Процессор (CPU) загружает машинные инструкции (секция `.text`) из временного файла в RAM, OS настраивает стек, регистры и передаёт управление кодовому блокy `_start` (или эквиваленту в Go-рантайме), далее вызывается `main.main()`, и ваша программа начинает работать.

5. **Очистка**

   - Когда программа завершила работу (ошибок нет, `main` вернула управление), Go-утилита ловит завершение процесса и удаляет временный исполняемый файл (или всю временную директорию). В итоге на вашем HDD/SSD ничего не остаётся, кроме исходников, которые вы писали.
   - Поэтому `go run` действительно эквивалентно «слегка смонтировать компьютер, скомпилировать, исполнить, а потом убрать следы» — всё быстро и «прозрачно» для пользователя.

### 2.2. Зачем это удобно

- **Быстро и без «мусора»**: не нужно каждый раз задумываться, куда сохранять результат, как назвать бинарник и не забыть удалить старую версию.
- **Разработка и тестирование**: вы часто правите код и тут же запускаете, не думая о сохранении старого файла. Это похоже на «интерактивный» цикл «правка-код → сохранить → запустить → увидеть результат» (без лишних телодвижений).
- **Локальные скрипты**: если у вас есть несколько маленьких утилит на Go (например, быстрая проверка чего-то), вы даже можете не создавать репозиторий или папку проекта: просто пишете файл, запускаете, всё, и бинарник исчез.

---

## 3. Что происходит при `go build`: создание «постоянного» бинарника

> **Автор:**
> «Unlike `go run`, which creates a temporary executable that exists only for the current session,
> `go build` creates a persistent binary executable file that you can run multiple times.»

### 3.1. Компиляция «в файл» на диске

1. **Чтение и обработка исходников (полностью аналогично `go run`)**

   - Go-компилятор считывает ваши `.go`-файлы с диска (HDD/SSD) в RAM.
   - Выполняет лексинг → парсинг → типовая проверка → SSA и оптимизации → генерацию машинного кода.

2. **Запись окончательного бинарника**

   - В отличие от `go run`, который создаёт временный исполняемый в «где-то», команда `go build` явно **пишет** итоговый файл в текущую папку (или ту, которую вы указали флагом `-o`).
   - Обычно, если вы просто запускаете `go build hello.go` (или `go build` внутри папки с файлом `hello.go`), Go кладёт полученный бинарник с именем без расширения:

     - на Windows: `hello.exe`
     - на Linux/macOS: `hello` (без расширения).

   - Этот файл хранится в той же директории, где вы находились, и не удаляется автоматически: он **постоянен**, пока вы сами его не сотрёте.

3. **Пример: работа с HDD/SSD и RAM**

   - Шаг компиляции: тот же набор чтения из HDD (исходники) → трансформация в RAM → линковка → запись нового файла на HDD.
   - Сравнения: если раньше (при `go run`) конечный файл оказывался «временным» и удалялся, то при `go build` он попадает в вашу папку (`HDD/SSD`) и остаётся там.

### 3.2. Запуск готового бинарника

- Когда вы хотите выполнить «постоянный» бинарник, вы просто вызываете команду ОС: `./hello` (или `hello.exe`).

- Что происходит «под капотом»:

  1. ОС читает заголовок ELF/PE/Mach-O из бинарника с HDD и решает, куда поместить код и данные в виртуальную память (RAM).
  2. Копирует секцию `.text` (машинный код) в область памяти, помеченную как исполняемая.
  3. Копирует `.data` и `.rodata` (данные, константы) в соответствующие области в RAM.
  4. Выделяет стек (stack) для основного потока и сегменты heap для динамической памяти.
  5. Устанавливает инструкционный указатель (Program Counter) на точку входа (метка `_start` Go-рантайма), запускает планировщик Go.
  6. CPU цепочкой инструкций достигает `main.main()`, далее идёт `fmt.Println` и т. д.

- После завершения программа остаётся записанной на диске. Вы можете её запускать сколько угодно раз, не дожидаясь компиляции, пока не внесёте в исходники изменения.

---

## 4. Когда стоит использовать `go run`, а когда — `go build`

> **Автор (продолжение):**
> «So when we are making APIs, when we are making softwares, we are constantly changing our code and we are constantly running our code with the updated changes.
> So in that case, we cannot repeatedly build the binary and then delete the previous binary and make another binary in its place.
> Instead of that we use `go run`. And when we are finally ready to make an executable for deployment, or for staging or for any other purpose that we want, we use `go build`.»

### 4.1. Цикл разработки и роль `go run`

1. **Частые правки кода**

   - Во время разработки (особенно на ранних стадиях), вы часто меняете одну-две строчки и тут же хотите протестировать, «не сломалось ли что-то».
   - Если вы будете каждый раз пользоваться `go build`, вам придётся:

     1. Отслеживать, куда сохраняется бинарник (например, `app` или `main.exe`).
     2. При переносе куда-то удалять старую версию (`rm app` или `del main.exe`).
     3. Пересобирать заново.

   - Это чревато лишними действиями: забыли удалить старый исполняемый — запускаете его по ошибке, результаты тестирования обманчивые.

2. **Как `go run` упрощает задачу**

   - Вы просто запускаете: `go run main.go` и получаете актуальный результат «свежесобранного» кода. Бинарник будет «где-то там» в временной папочке и через секунду после завершения работы исчезнет.
   - Это «циклично»:

     1. Правка кода →
     2. `go run main.go` →
     3. Смотрим результат →
     4. Правка кода →
     5. `go run main.go` → …

   - Пространства для ошибок меньше: вы гарантированно запускаете именно «свежесобранный» код, а не старый бинарник, и не нужно следить за накоплением «мусора» файлов.

3. **Когда `go build` всё-таки уместен**

   - Когда вы **готовитесь к деплою** (выгружаете приложение в продакшн или на staging-сервер).
   - Тогда вы фиксируете версию (например, git-tag), делаете `go build -o myservice_v1.2.3` и получаете на диске единственный бинарник, который можно копировать на другие сервера, запускать в контейнере, паковать в RPM/DEB и т. д.
   - Такой подход удобен, потому что бинарник «постоянный» (вы его не перезапишете нечаянно), и его легко архивировать, проверять контрольную сумму (md5/sha), вешать подпись.

---

## 5. Как всё это выглядит «под капотом» с точки зрения ресурсов компьютера

### 5.1. HDD/SSD

- **`go build`**

  - В момент компиляции:

    1. Исходники (`.go`) и, возможно, другие файлы (mod, sum) читаются с диска (HDD/SSD) → RAM.
    2. Результат линковки (бинарник) записывается на диск (HDD/SSD).

  - После этого бинарник остаётся там, и каждый раз, когда вы запускаете `./mybinary`, ОС снова читает файл с HDD/SSD → загружает части в RAM → запускает CPU.

- **`go run`**

  - В момент компиляции часть файлов (например, же `hello.go`) читаются с диска → RAM.
  - Временный бинарник может быть записан в папку `/tmp` на диске (HDD/SSD), но лишь на время работы.
  - При завершении работы Go-утилита удаляет этот временный файл, и на вашем основном диске в папке проекта не остаётся новых файлов. Поэтому «пространства на диске» вы фактически не тратите под каждый запуск.

### 5.2. RAM

- **Общие моменты**

  - Операции компиляции (лексинг, парсинг, оптимизации) очень активно используют RAM: компилятор загружает AST и SSA в оперативную память, строит таблицы символов, строит промежуточные структуры и т. д.
  - Во время генерации машинного кода те же данные хранятся в оперативке, пока не линкуются в единый файл.

- **При `go run`**

  - Большая часть всего процесса живёт только в RAM (или во временных файлах на /tmp, зависящих от вашей ОС):

    - AST и SSA — в оперативной памяти.
    - Временный бинарник — либо в оперативной памяти (если Go-toolchain позволяет «запустить из RAM»), либо в `/tmp` (т. е. «быстрый SSD»).

  - После завершения — ВСЁ, что касалось этой сборки, «прибрано»: память освобождена, временные файлы удалены, и никакой «след» не остаётся (кроме вашего исходного `.go`).

- **При `go build`**

  - Всё время компиляции та же самая нагрузка на RAM.
  - Только конечный бинарник вы «перекладываете» в вашу папку проекта (или куда укажете). Он тоже обычно хранится на HDD/SSD, но может некоторое время также кэшироваться в RAM (операционная система часто держит часто используемые части бинарника в «файловом кэше» для более быстрого запуска).

### 5.3. CPU

- **Компиляция (gc compiler)**

  - Go-компилятор активно загружает ядра CPU:

    - Стадия SSA-оптимизаций может распараллеливать работу, используя несколько потоков.
    - Генерация машинного кода (codegen) тоже зачастую задействует несколько ядер, чтобы быстрее превратить каждую функцию в машинные инструкции.

- **Линковка**

  - Линковщик (linker) тоже требует вычислительных ресурсов, особенно когда бинарник большой и множество зависимостей (стандартных библиотек) нужно объединить.

- **При `go run`**

  - CPU выполняет те же операции компиляции → линковки, но потом сразу же запускает полученный процесс. Как только вы завершили программу, CPU «возвращается к тому, что нужно делать дальше» (заканчивается процесс).

- **При `go build`**

  - CPU делает компиляцию → линковку → запись файла на диск. Затем работа CPU над этим командуется завершена, и дальше CPU может выполнять ваши другие задачи, пока вы вручную не запустите созданный бинарник.

---

## 6. Итоги и рекомендации

1. **`go run`**

   - **Когда:** когда вы быстро тестируете изменения, работаете над прототипом, локальной маленькой программой, скриптом.
   - **Что важно знать:**

     - Временный бинарник не останется на диске ваших исходников.
     - Компиляция выполняется каждый раз «с нуля» (либо с учётом кэша, но бинарник всё равно создаётся заново).
     - Если программа большая (много файлов, пакетов), каждый запуск `go run` будет требовать больше времени на сборку.

2. **`go build`**

   - **Когда:** когда вы готовы получить «постоянный» бинарник. Например:

     - Для деплоя на сервер.
     - Для упаковки в Docker-контейнер.
     - Когда хотите протестировать реальный (без сопровождения go-рантайма) запуск (чтобы убедиться, что бинарник запускается корректно «сам по себе»).

   - **Что важно знать:**

     - Бинарник сохраняется в директории, где вы вызвали `go build` (или в том пути, что указали через флаг `-o`).
     - После этого вы можете запускать его сколь угодно раз без повторной сборки.
     - Размер бинарника может быть существенно больше, чем исходный код, потому что туда «вшивается» рантайм Go, GC, планировщик горутин, таблицы символов и т. д.

3. **Практический совет**

   - На ранних этапах **разработки** используйте `go run` — быстрее, удобнее, нечего вручную чистить.
   - Перед **релизом** или перед **деплоем** сделайте `go build -o myapp_vX.Y.Z`, сохраните версию, пропишите контрольную сумму, убедитесь, что бинарник работает.
   - Если же вы создаёте утилиту (CLI) и собираетесь её инсталлировать локально, часто удобнее `go install` (он компилирует и кладёт бинарник в `$GOPATH/bin` или `$HOME/go/bin`).

---

### Краткая диаграмма «что и где хранится»

| Действие           | Исходники (`.go`)         | Временный бинарник                                    | Постоянный бинарник                               |
| ------------------ | ------------------------- | ----------------------------------------------------- | ------------------------------------------------- |
| `go run main.go`   | HDD/SSD (постоянно) → RAM | `/tmp/.../main` (HDD/SSD или RAM, но удаляется сразу) | отсутствует                                       |
| `go build main.go` | HDD/SSD (постоянно) → RAM | не создаётся (кроме .o → RAM)                         | `./main` (или `main.exe`) на HDD/SSD              |
| `go install`       | HDD/SSD (постоянно) → RAM | не создаётся явным образом                            | `~/go/bin/main` или `$GOPATH/bin/main` на HDD/SSD |

- Везде: исходники всегда лежат **долго** на HDD/SSD.
- **Временный бинарник** при `go run` живёт **пока процесс не завершится**, а потом удаляется.
- **Постоянный бинарник** при `go build` остаётся там, где вы его записали, и живёт до тех пор, пока вы сами его не удалите.

---

## Заключение

- **Основная идея автора**:

  1. `go run` → мгновенная «сборка + запуск», без мусора на диске.
  2. `go build` → собрать «раз и навсегда» (persistent) бинарник, которым можно пользоваться много раз, копировать, деплоить.
  3. Во время активной разработки (когда код часто меняется) привычнее и удобнее пользоваться `go run`, потому что не нужно ждать, пока старый бинарник будет удалён, или думать, куда его положить.
  4. Когда всё готово и пора публиковать/деплоить, «финально» собираем с помощью `go build`.

- **Что происходит «под капотом»**:

  1. Чтение исходников (HDD → RAM).
  2. Лексинг → Парсинг → Оптимизации → Генерация машинных инструкций (в RAM).
  3. Линковка («сборка» объектов Go-рантайма и пакетов) → формирование ELF/PE-файла.
  4. При `go run` бинарник временно хранится в RAM/`/tmp`, сразу же запускается, и по завершении удаляется.
  5. При `go build` бинарник сохраняется на HDD/SSD в указанной вами директории, и потом его можно запустить повторно без перекомпиляции.

Понимание этих механизмов поможет вам выбирать подходящий инструмент на каждой стадии разработки и лучше ориентироваться в том, какие ресурсы (диск, память, CPU) задействуются при компиляции и запуске Go-программ.
