Вводная: зачем вообще понимать разницу между go run и go build
Что такое Go?
Go (или Golang) — это язык программирования и набор инструментов, которые позволяют написать программу (код) и превратить его в исполняемую программу (бинарник), которую можно запустить на компьютере.

Что делает команда go run?
Она «на лету» собирает (компилирует) ваш код и сразу же запускает его, не оставляя после себя файла, который можно было бы запускать снова и снова.

Что делает команда go build?
Она собирает (компилирует) ваш код и сохраняет результат в виде постоянной программы (файла-­приложения), которую можно запускать сколько угодно раз.

Если эти понятия (компиляция, бинарник, HDD/SSD, RAM) вам пока ничего не говорят — не переживайте. Дальше мы всё разложим «по полочкам».

1. Почему вообще спрашивают: «зачем go run, если есть go build?»
   Автор говорит:
   «Почему мы используем go run, когда можно просто сделать go build? Всё просто. go build создаёт «постоянную» программу (бинарник), тогда как go run создаёт «временную» программу и сразу же её запускает, но не оставляет на диске.»

1.1. Коротко о «постоянном» и «временном» бинарнике
go build (постоянный бинарник)

Когда вы запускаете go build, Go-утилита читает ваши файлы с расширением .go (исходники), преобразует их в машинный код (инструкции для процессора) и записывает получившийся файл (называемый «бинарником») рядом с вашими исходниками (обычно в ту же папку).

Этот файл остаётся на диске пока вы его не удалите. При следующем запуске такой программы повторно компиляция не нужна — вы просто запускаете уже готовую программу.

go run (временный бинарник)

Когда вы запускаете go run, Go-утилита тоже читает исходники, компилирует их в машинный код, но не кладёт результат в ту папку, где лежат ваши .go-файлы. Вместо этого Go быстро создаёт (временный) исполняемый файл где-то «на время» (например, в папке /tmp или даже может держать его «только в памяти»).

Как только скомпилированная программа завершила свою работу, Go сам удаляет этот временный файл. В папке с вашими .go-исходниками ничего не остаётся, кроме самих исходников.

Почему «persistent» (постоянный) и «temporary» (временный) важны?
Постоянный бинарник (go build):

Вы можете запускать его сколько угодно раз, не думая о пересборке.

Его можно копировать (например, на другой сервер или другу), хранить копии, подписывать цифровой подписью (для безопасности).

Это удобно, когда вы уже «доделали» программу и хотите, чтобы она жила как отдельный файл.

Временный бинарник (go run):

Удобен во время разработки, когда вы часто меняете код и сразу же хотите его проверить.

Не оставляет «мусора» в папке проекта: каждый раз — «сборка, запуск, удаление».

Если вы запускаете маленькую утилиту на раз-два, не нужно думать, куда положить файл-­программу — Go всё сам убирает сразу.

2. Подробно, что происходит при go run: «сборка + запуск» за один шаг
   Автор говорит:
   «go run компилирует и сразу запускает программу, не создавая постоянного файла. Go берёт ваши .go-файлы, с помощью компилятора создаёт временный бинарник (обычно где-то в /tmp или в оперативной памяти), запускает его, а после завершения программы удаляет этот временный файл.»

Разберём по шагам, что реально делает компьютер, когда вы в консоли пишете:

bash
Копировать
Редактировать
go run myprog.go
2.1. Шаг 1: Чтение исходных файлов (HDD/SSD → RAM)
Исходник (.go)

Допустим, у вас есть файл myprog.go на жёстком диске (HDD) или SSD. Это просто текстовый файл с кодом Go.

Когда вы запускаете go run myprog.go, операционная система (Windows, Linux, macOS) просит: «Открой файл myprog.go».

Компьютер читает этот файл из хранилища (HDD/SSD) и загружает его содержимое в оперативную память (RAM), потому что дальше все операции — это работа с текстом и разбор кода, и это всё удобнее делать именно в RAM (там быстрее).

Почему RAM?

RAM (оперативная память) работает в разы быстрее, чем HDD или SSD. Поэтому весь «мозг» компилятора живёт в RAM: там он хранит промежуточные версии вашего кода, данные о функциях, переменных, «граф» зависимостей между кусочками кода и т. д.

2.2. Шаг 2: «Сборка» кода (лексинг, парсинг, оптимизации, генерация машинного кода)
После того как строки с кодом (package main, func main() { ... } и т. д.) оказались в RAM, Go-компилятор делает следующие этапы (они происходят «внутри» процесса go и тоже в оперативной памяти — никакой бинарник ещё не записан надолго на диск):

Лексинг (лексер)

Компилятор читает весь текст кода и разбивает его на части: ключевые слова (package, func, import), имена переменных, символы (=, {, }, (, )), числа, строки и т. д.

Эта разбивка на «лексемы» (токены) нужна, чтобы дальше понимать, что именно вы написали: «это ключевое слово», «это имя функции», «это число» и т. д.

Парсинг (синтаксический анализ)

Уже из «лексем» компилятор строит «дерево разбора» (AST, Abstract Syntax Tree).

Например, строка fmt.Println("Hello") становится в дереве примерно так:

bash
Копировать
Редактировать
Вызов функции
├─ пакет: fmt
├─ имя функции: Println
└─ аргументы
└─ строковый литерал: "Hello"
На этом этапе компилятор понимает, какая структура у вашего кода, какие есть функции, какими именами они называются, какие параметры ожидают и т. д.

Проверка типов (type checking)

Go — это язык со строгой статической типизацией. Компилятор проверяет, что вы, например, не пытаетесь сложить строку и число, что в функцию переданы правильные аргументы и т. д.

Если вы в коде сделали опечатку или неверно использовали типы, компилятор остановится на этом этапе и выдаст ошибку, например:

csharp
Копировать
Редактировать
cannot use "abc" (untyped string) as type int in assignment
Пока есть ошибки, Go не перейдёт к следующим шагам.

Преобразование в промежуточное представление (SSA) и оптимизации

После того как компилятор «понял», что ваш код синтаксически и по типам правильный, он строит ещё более «низкоуровневое» представление внутреннего кода (SSA — Single Static Assignment).

На этом этапе компилятор может выполнять оптимизации: исправлять неэффективные конструкции, убирать мёртвый код (который никогда не будет выполняться), объединять одинаковые выражения и т. д.

Вся эта информация хранится в оперативной памяти (RAM), в виде набора структур и графов зависимостей.

Генерация машинного кода (codegen)

Теперь компилятор «переводит» оптимизированный код в реальные инструкции, которые поймёт процессор (CPU).

Например, для x86-64 (самая распространённая архитектура для ПК и серверов) эти инструкции — это последовательности байтов, говорящие CPU:

sql
Копировать
Редактировать
MOV RAX, [адрес]
ADD RAX, 5
CALL fmt.Println
RET
Эти инструкции образуют один «целостный» файл, который называется «исполняемым» (binary, бинарник).

Линковка (linking)

Go-программа не живёт «сама по себе». В неё входит рантайм Go (гонсчётчик горутин, сборщик мусора, базовые функции ввода-вывода и т. д.) и, возможно, сторонние библиотеки (если вы их подключали через import).

Линкер берёт ваш сгенерированный машинный код (объектный файл, обычно с расширением .o) и «склеивает» его со всеми нужными фрагментами рантайма и библиотек так, чтобы получился один самодостаточный файл, который можно запустить.

В итоге появляется уже полноценный исполняемый файл (ELF на Linux, PE на Windows, Mach-O на macOS).

➔ Важно: всё это (лексер, парсер, SSA, codegen, линковка) происходит в RAM и, возможно, с небольшими временными файлами в системной «временной» папке (например, /tmp на Linux). Пока компилятор не закончит линковку, «постоянного» бинарника в вашей папке проекта не появится.

2.3. Шаг 3: Создание временного исполняемого файла
После того как компилятор и линкер собрали весь код, Go создаёт файл-­бинарник.

На практике он кладёт этот бинарник куда-то в «временную рабочую область» (обычно в /tmp на Unix-подобных системах или во внутреннюю папку, заданную ОС).

Этот файл — полноценная исполняемая программа, но Go заранее «знает», что этот файл нужен только «на время», чтобы сразу же запустить программу.

Часто говорят, что «бинарник хранится в RAM», но реально на диске (SSD/HDD) он может быть записан в папку /tmp. Иногда компилятор может «неписать» его на диск, а держать в RAM-­файловой системе (tmpfs), но с точки зрения пользователя важно: никак не сохраняется в папке вашего проекта.

2.4. Шаг 4: Запуск временного исполняемого файла (CPU + RAM)
Создание процесса

Go вызывает системный вызов вроде execve (Linux) или CreateProcess (Windows), чтобы ОС запустила сгенерированный временный файл как отдельный процесс.

В результате появляется новый процесс, которому ОС «делегирует» ресурсы:

Куча (heap) в RAM для динамических данных.

Стек (stack) в RAM для хранения локальных переменных и вызовов функций.

Блок памяти для кода (.text) и данных (.data, .rodata).

CPU начинает исполнять инструкции

Процессор (CPU) читает первые инструкции из секции .text временного бинарника, переводит их в транзисторные сигналы и выполняет.

Сначала идёт точка входа \_start (низкоуровневая часть рантайма Go), она инициализирует рантайм, запускает планировщик горутин (Go-корутин), а потом вызывает вашу функцию main.main().

Дальше ваши функции выполняются как обычно: могут печатать в консоль (fmt.Println), читать файлы, обращаться к сети — всё как написано в коде Go.

Выполнение и завершение

Пока ваша программа работает (пока main не завершил своё выполнение и не вышел из кода), процесс «живёт» в RAM (на самом деле часть данных может сбрасываться в своп, но об этом позже).

Когда main заканчивается или программа делает os.Exit(0), процесс «умирает»: ОС освобождает все ресурсы (RAM, дескрипторы файлов, сокеты).

2.5. Шаг 5: Удаление временного исполняемого файла (чистка мусора)
Сразу после того, как процесс завершился, Go-утилита (go run) понимает, что «цели достигнуты»: программа отработала.

Она автоматически удаляет временный бинарник из той папки /tmp или из «виртуальной» файловой системы в RAM.

Ваша папка проекта остаётся «чистой» — там только исходники и, возможно, какие-то сгенерированные вами файлы (но не сам бинарник).

➔ Итого при go run:

Вы ввели go run myprog.go.

Go-утилита:

Считала код из диска → загрузила в RAM.

С помощью компилятора → линковщика создала временный бинарник (в /tmp или «в RAM»).

Запустила этот бинарник.

Дождалась завершения работы.

Удалила бинарник.

В папке с исходниками ничего не осталось, кроме файлов .go.

3. Подробно, что происходит при go build: «сборка → запись → готовый файл»
   Автор говорит:
   «В отличие от go run, go build создаёт «постоянный» бинарник, который остаётся на диске, и которым вы можете пользоваться много раз.»

Тот же самый процесс компиляции + линковки, но с несколькими отличиями.

3.1. Шаг 1: Чтение исходников (HDD/SSD → RAM)
Go читает все .go-файлы вашего пакета (или конкретного файла hello.go, если вы явно указали).

Эти файлы загружаются в RAM.

Дальше всё то же самое: лексинг, парсинг, проверка типов, оптимизации, генерация машинного кода, линковка — всё это происходит «в RAM».

Важно: на этом этапе компиляция в целом не отличается от go run: Go-компилятор точно так же строит AST, SSA, оптимизирует и т. д.

3.2. Шаг 2: Запись бинарника на диск (HDD/SSD)
Когда компилятор+линкер сформировали полноценный исполняемый файл (который умеет работать самостоятельно без участия go-утилиты), go build записывает этот файл туда, где вы сказали.

Если вы просто запустили go build hello.go (или находясь в папке с hello.go набрали go build), Go положит результат в текущую папку:

Linux/macOS: файл с именем hello (без расширения).

Windows: файл hello.exe.

Замечание про флаг -o:
По умолчанию go build сам выберет имя файла (название папки или файла-­исходника). Но если вы хотите назвать бинарник по-своему, можно сделать:

bash
Копировать
Редактировать
go build -o myapp_v1.2.3
Тогда в папке появится именно файл myapp_v1.2.3 (на Windows, если вы не указали .exe, Go сам добавит расширение).

3.3. Шаг 3: Запуск готового бинарника (очередной запуск без перекомпиляции)
Как запустить?

В Linux/macOS:

bash
Копировать
Редактировать
./hello
В Windows:

powershell
Копировать
Редактировать
.\hello.exe
Что делает ОС при запуске созданного файла?

Считывает заголовок ELF/PE/Mach-O с диска (то есть смотрит, какой формат у файла, куда «класть» код в память, где какие сегменты).

Копирует сегцию с машинным кодом (.text) и данные (.data, .rodata) в RAM.

Выделяет стек (RAM) для основного потока, настраивает регистры, указатель инструкций (Program Counter) указывает на точку входа (\_start).

ОС передаёт исполнение процессору (CPU), он начинает читать инструкции и выполнять их. Сначала рантайм Go инициализируется, потом вызывается ваша функция main.main(), и ваша программа «идёт».

Что меняет по сравнению с go run?

Нет шага «удалить файл» после окончания. Бинарник остаётся на диске и может быть запущен снова без пересборки.

Если вы изменили исходники, повторно запустить этот старый бинарник не имеет смысла — он будет работать как раньше, без ваших новых правок. Чтобы запустить изменения, нужно снова сделать go build.

3.4. Краткий итог по go build
Всё то же, что и при go run, через компиляцию и линковку.

Отличие: вместо временного бинари­ника вы получаете файл в вашей папке, он не удаляется автоматически.

Плюсы:

Удобно, когда программа готова и вы хотите её «раскатать» (деплоить, передать кому-то).

Можно подсчитать контрольные суммы (SHA-1, MD5), проверить, что бинарник не изменился.

Можно положить файл в Docker-образ, создать .deb/.rpm-пакет (для Linux-дистрибутивов), установить его как сервис и т. д.

4. Когда использовать go run, а когда — go build
   Автор говорит:
   «Во время разработки, когда код постоянно меняется, лучше пользоваться go run, чтобы не удалять каждый раз старый бинарник. А когда вы готовы к деплою (релизу), используйте go build, чтобы получить «финальный» файл.»

4.1. Рекомендация № 1: Цикл разработки (go run)
Частые правки и быстрый тест

Представьте, что вы пишете код и каждую минуту исправляете одну строчку: добавили новый fmt.Println, поменяли условие, поправили функцию.

С go run достаточно каждый раз набрать:

bash
Копировать
Редактировать
go run main.go
Команда сама сделает «сборку» и «запуск» в одну операцию.

Вам не нужно думать: «А что, если остался старый бинарник? А куда я его положил? Не удалил ли я его?»

Нет «мусора» в папке проекта

Каждый раз вы получаете чистую папку: никакого файла hello, никакого hello.exe. У вас только .go-файлы и, может быть, другие ресурсы (картинки, конфиги).

Если бы вы постоянно делали go build, со временем в папке скопилось бы много разных версий бинарников, а вы могли бы случайно запустить не ту версию.

Скорость

Если проект очень маленький (один файл на пару десятков строчек), время компиляции минимально, и разница между go run и go build && ./hello почти неощутима.

Если проект крупный (много пакетов, зависимостей), каждый запуск go run (или go build) занимает ощутимое время. Но по-прежнему go runчище с точки зрения удобства.

4.2. Рекомендация № 2: Деплой и релиз (go build)
Когда вы «окончательно» закончили работу над версией программы

Например, у вас получился сервис версии 1.0. Вы хотите собрать бинарник для Linux x86_64 и положить его на сервер.

Вы делаете:

bash
Копировать
Редактировать
go build -o myservice_v1.0
В папке появится myservice_v1.0.

Вы можете проверить контрольную сумму команды:

bash
Копировать
Редактировать
sha256sum myservice_v1.0
и гарантировать, что этот файл точно такой, каким вы хотите его раздать.

Дальнейшие преимущества

Повторный запуск. Любой, у кого есть доступ к этому файлу, может запустить его без Go-установки (Go-рантайма) на машине, потому что бинарник уже «самодостаточный»: внутри него уже есть всё, что нужно.

Копирование и перенос. Можно передать файл на сервер, добавить в образ Docker, запаковать в архив, разместить на другом компьютере.

Изоляция от исходников. Если кто-то найдёт файл myservice_v1.0 и запустит его, никак не сможет «сломать» исходники, потому что у него нет доступа к .go-файлам (это некий «чёрный ящик»).

Использование в качестве утилиты

Иногда вы хотите установить программу глобально на своём компьютере. Тогда есть команда go install. Она делает что-то вроде:

bash
Копировать
Редактировать
go install ./...  
или

bash
Копировать
Редактировать
go install github.com/user/project@latest  
— и результат (бинарник) кладётся в папку $GOPATH/bin (обычно ~/go/bin).

После этого команда, например, myservice доступна в любой папке (если $GOPATH/bin есть в переменной среды PATH).

5. Что реально происходит «под капотом» с ресурсами компьютера
   Часто, чтобы увидеть разницу между go run и go build, полезно представить, какие ресурсы (HDD/SSD, RAM, CPU) задействуются и когда.

5.1. Жёсткий диск (HDD/SSD)
Исходники всегда лежат на диске

Файлы \*.go, go.mod, go.sum — это обычные файлы, постоянно хранящиеся в папке вашего проекта на HDD (жёстком диске) или на SSD (твердотельном накопителе).

Что происходит при go run с диском

Чтение исходников: Go читает файлы .go с диска.

Временный бинарник:

Чаще всего Go создаёт папку в системе, которая называется что-то вроде /tmp/go-build12345/. В ней появляются промежуточные файлы (файлы .o) и сам временный бинарник.

Эти файлы записываются на диск (или, если ваша система настроена, в RAM-диск, впечатление такое, что они хранятся в RAM).

Как только программа завершилась, Go удаляет папку /tmp/go-build12345/ вместе с бинарником и промежуточными файлами.

Итог: после go run в вашей папке проекта ничего не осталось, а из системных временных файлов всё убрано.

Что происходит при go build с диском

Чтение исходников: точно так же.

Постоянный бинарник: вместо папки /tmp Go создаёт файл в той папке, откуда вы вызвали go build (или в том пути, что вы указали через -o).

После завершения в папке проекта остаётся новый файл, допустим, hello или hello.exe. Он находится на HDD/SSD «навсегда» (пока вы не удалите).

5.2. Оперативная память (RAM)
Во время компиляции

Почти всё, что касается «умных» операций (лексинг, парсинг, оптимизации, генерация машинного кода), происходит в оперативной памяти.

Компилятор строит AST (дерево), SSA (промежуточное представление), и для этого нужны большие объёмы RAM, особенно если проект крупный.

Когда создаётся временный бинарник (go run)

Часть компиляции держится в RAM, но в какой-то момент Go создаёт файлы в /tmp.

Когда бинарник запускается, ОС загружает сам исполняемый файл (содержимое секций .text, .data) в RAM.

Пока программа работает, весь её код и данные живут в RAM (в разных сегментах). Как только процесс завершается, операционная система «освобождает» эту память и удаляет временные файлы (если они были на диске).

Когда создаётся постоянный бинарник (go build)

Компиляция опять же сильно нагружает RAM.

Когда линкер собрал и записал файл на диск, ОС всё равно для ускорения может держать недавно использованные части этого файла в так называемом «кэше» файловой системы: фактически это часть RAM, где копируются буферы диска.

Но главное: бинарник лежит на диске, и каждый раз при запуске ОС будет загружать лишь нужные для выполнения части (обычно это секции с кодом и данными) в RAM.

5.3. Процессор (CPU)
Компиляция

Лексер и парсер — это не очень ресурсоёмкие этапы, но вот SSA-оптимизации и генерация машинного кода могут использовать несколько ядер CPU (Go-­компилятор умеет распараллеливать некоторые задачи).

Линковка большого проекта (множество пакетов) тоже немного «процессороёмкая», но не так сильно, как, например, компиляция C++-проекта. Go-компилятор спроектирован так, чтобы быть относительно быстрым.

При go run

CPU последовательно выполняет: чтение файлов → лексинг/парсинг → SSA → codegen → линковка → вызов нового процесса (execve) → исполнение вашей программы.

Когда ваш код начинает работать (в main.main()), CPU переключается на выполнение инструкций вашей программы (вычисления, чтение/запись, работа с сетью и т. д.). После завершения программа выдаёт результаты (в консоль, файл и т. д.), а процесс CPU возвращается к тому, что ему нужно делать дальше (к остальным задачам операционной системы или другим вашим программам).

При go build

То же самое, но на этапе «запись бинарника» CPU выполняет дополнительный простой шаг: взять готовый файл из RAM и записать его на диск (HDD/SSD).

После этого компиляция закончена, и CPU переключается на другие задачи. Бинарник с вашего взгляда «хранится» на диске, а CPU в дальнейшем может куда-то кэшировать части этого файла, если вы запустите его.

6. Итоги и простые рекомендации
   6.1. Когда использовать go run
   Вы только что написали кусочек кода (например, пару строк) и хотите сразу проверить, что он делает, без лишних манипуляций с файлами.

Частая доработка: вы правите что-то каждую минуту, и нужно как можно быстрее запустить и увидеть результат.

Не нужно думать про имя бинарника, его удаление и т. д.: Go сам всё сделает «на время».

Вы не хотите «загрязнять» папку проекта кучей разных версий бинарников.

6.2. Когда использовать go build
Вы закончили работу над версией программы и хотите получить файл, который потом можно запустить без Go.
Например, вы разрабатываете команду CLI, которую нужно раздать коллегам, или серверное приложение, которое отправляется на продакшн.

Вам нужно сохранить бинарник навсегда (хотя бы до тех пор, пока вы сами не удалите).
Например, вы делаете релиз: go build -o myapp_v1.0, проверяете контрольную сумму, можете залить бинарник на GitHub Release или куда-то ещё.

Установка утилиты на системном уровне: go install автоматически скомпилирует и положит бинарник в ~/go/bin (или $GOPATH/bin), добавит его в ваш PATH — и программу удобно запускать везде.

6.3. Сравнительная таблица «что, где, когда хранится»
Действие Исходники (.go) Временный бинарник Постоянный бинарник
go run main.go HDD/SSD → RAM (читаются) /tmp/.../main (или RAM, но удаляется) отсутствует
go build main.go HDD/SSD → RAM (читаются) промежуточные .o (RAM, пока компиляция) ./main (или main.exe) на HDD/SSD, остаётся
go install HDD/SSD → RAM (читаются) промежуточные .o (RAM) ~/go/bin/main (HDD/SSD), остаётся

Исходники всегда «живут» на диске (вы их написали и сохранили).

Временный бинарник при go run — «живет» только до тех пор, пока процесс не закончится, а затем удаляется.

Постоянный бинарник при go build остается на диске, пока вы сами его не удалите.
